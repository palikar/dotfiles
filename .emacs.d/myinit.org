#+startup: overview

#+title: Configuration file for my EMACS
#+AUTHOR: Stanislav Arnaudov
#+DATE: 18-04-2018
#+EMAIL: stanislav_ts@abv.bg
#+LANGUAGE: En
#+EXPORT_FILE_NAME: config_emacs
#+CREATOR: Emacs 24.3.50.3 (Org mode 8.0.3)
#+SELECT_TAGS: export
#+EXCLUDE_TAGS:noexport no_export
#+EXCLUDE_TAGS: no_export
#+CREATOR: Emacs 25.2.2 (Org mode 9.1git remote add origin https://github.com/palikar/jgrapher.git.13)

#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t todo:t |:t
#+OPTIONS: toc:2




* Abstract
This is the cofiguration of my EmonkeysMACS-Editor written in [[https://orgmode.org/][Org mode]] in [[https://en.wikipedia.org/wiki/Literate_programming][literate style programming]]. I've sort of hoarded a lot of different packages and different =.emacs= files from all over the internet and just stucked them together.\\
Using the configuraion as is it is is not really advisable. Some things may seem weird and 'wrongly' configured, but hey...this is EMACS.\\
Still, you may found some hidden gems in here that can greatly simplify your work with the editor. I don't use =[[https://github.com/jwiegley/use-package][use-package]]= as I found that it actually makes my emacs slugish on windows and I actually prefer to have everything in my local config all the time.\\
Download the repo with
#+BEGIN_EXAMPLE
git clone https://github.com/palikar/dotfiles
#+END_EXAMPLE
and setupe emacs 
#+BEGIN_EXAMPLE
. setup-emacs.sh
#+END_EXAMPLE
//
I've drawn a lot of inspiration for my Emacs configuration form:
- [[https://github.com/zamansky/using-emacs][here]] (for the genera concept of the configuration file)
- [[https://sriramkswamy.github.io/dotemacs/][also here]] (for the all of the /hydras/)
* Repos and packages
The default packages repo for emacs is ELPA. ELPA is not super good, we also want MELPA. +MELPA is configured in the .emacs file but here we also add ELPA for good measures+ Everything is here now!
#+BEGIN_SRC emacs-lisp :results none
(require 'package)
(package-initialize)

(add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
(add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)
(add-to-list 'package-archives '("melpa2" . "http://www.mirrorservice.org/sites/melpa.org/packages/"))
(add-to-list 'package-archives '("melpa3" . "http://www.mirrorservice.org/sites/stable.melpa.org/packages/"))
(add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/") t )

(package-refresh-contents)
#+END_SRC
** Installing packages
I use a lot of aditional packages and like to keep them local and installed. I've tried =use-package= but I had some issues and I've opted out for installing everything. The initial waiting when setting up emacs config from scratch is fine by me.
#+BEGIN_SRC emacs-lisp
                                        ; all of my packages that I want in my config
(setq package-list '(aggressive-indent alect-themes anzu atom-dark-theme auto-complete-clang auto-complete-clang-async auto-complete-nxml auto-org-md base16-theme beacon clang-format cmake-ide cmake-mode color-theme-modern company-auctex auctex company-bibtex company-c-headers company-cmake company-emacs-eclim company-irony company-irony-c-headers company-jedi company-rtags cquery crux ctags-update dashboard doom-themes dot-mode drag-stuff dumb-jump easy-hugo easy-kill eclim ein auto-complete elpy emmet-mode expand-region exwm find-file-in-project flycheck-irony flyspell-correct-popup flyspell-correct flyspell-popup function-args google-this google-translate graphviz-dot-mode haskell-mode helm-c-yasnippet helm-flycheck helm-ispell helm-projectile helm-rtags helm helm-core highlight-indentation hugo hungry-delete ibuffer-projectile irony-eldoc irony iy-go-to-char java-imports java-snippets jedi-core epc ctable concurrent json-mode json-reformat json-snatcher latex-pretty-symbols latex-preview-pane levenshtein lorem-ipsum lsp-mode markdown-mode maven-test-mode meghanada company moe-theme molokai-theme monokai-theme mvn mvn-help neotree noflet org-bullets org-page git mustache org-pdfview org2blog htmlize metaweblog ox-gfm ox-hugo ox-reveal org ox-twbs page-break-lines parsebib pcache pdf-tools popup-complete popup powerline-evil evil goto-chg pretty-mode python-environment pyvenv request-deferred request deferred rtags skewer-mode js2-mode simple-httpd smart-hungry-delete smart-mode-line-powerline-theme smart-mode-line rich-minority powerline smartparens solarized-theme spacemacs-theme srefactor sublimity swiper ivy syntax-subword tablist telephone-line treemacs-projectile treemacs ht hydra pfuture ace-window avy projectile try undo-tree use-package bind-key vimrc-mode virtualenvwrapper web-mode websocket workgroups workgroups2 f s anaphora wrap-region xelb xml-rpc yasnippet-snippets yasnippet zeal-at-point zerodark-theme flycheck seq pkg-info epl magit magit-popup git-commit with-editor ghub let-alist dash async all-the-icons memoize))





                                        ; activate all the packages (in particular autoloads)
(package-initialize)

                                        ; fetch the list of packages available 
(unless package-archive-contents
  (package-refresh-contents))

                                        ; install the missing packages
(dolist (package package-list)
  (unless (package-installed-p package)
    (package-install package)))


#+END_SRC
* Key bindings custom map 
Some major modes overwrite some of my custom keybindings. Therefore I define a custom global minor mode and use the key map of this mode to define my custom key bindings. This sets their precedence 'above' the precedence of the key bindings of other modes
#+BEGIN_SRC emacs-lisp :results none
(define-minor-mode my-keys-mode
  "Minor mode for my personal keybindings."
  :global t
  :keymap (make-sparse-keymap))


(setf (cdr my-keys-mode-map) nil)

(my-keys-mode t)
#+END_SRC
* Interface tweaks
Making the whole =emacs= experience a tiny bit better with those fixes of the interface of the editor
- Startup screen is anoying
- The toolbar is wasting sapce
- =f5= should function as a refresh in firefox
- Fringes waste space
- Numbered lines come in handy
- Highlighting the current line is pretty =übersichtlich=
- Pretty sybols like \lambda over the whole place is pretty cool
- [[https://elpa.gnu.org/packages/nlinum.html][nlinum]] - a mode to display the linenumbers but it's much more efficient than the build in /linum/-mode. /nlinum/ can handle big files without a hicup while scrolling.
#+BEGIN_SRC emacs-lisp :results none
(setq inhibit-startup-message t)
(tool-bar-mode -1)
(define-key my-keys-mode-map (kbd "<f10>") 'tool-bar-mode)
(menu-bar-mode -1)
(define-key my-keys-mode-map (kbd "<f9>") 'menu-bar-mode)

(fset 'yes-or-no-p 'y-or-n-p)
(fringe-mode '(0 . 0))
(setq-default cursor-type 'bar)
(global-nlinum-mode t)
(global-visual-line-mode 1)
(global-hl-line-mode 1)    
(global-prettify-symbols-mode +1)

#+END_SRC
* Behavioral tweaks
Some quick fixes for intuitinve and streight forwawrd editing. Generally I strive for the cleanest designf the interface possible so I remove a lot from the unneccesery things that come by default with EMACS.
#+BEGIN_SRC emacs-lisp :results none
(setq-default indent-tabs-mode nil)
(delete-selection-mode 1) ;; it's really weird working without that
(setq auto-save-default nil)
(setq backup-inhibited t)
;; (cua-mode 1) I am pretty much a big deal pro and I don't need cua-mode 8)
(load "~/.emacs.d/lisp/syntax-subword") 
(global-syntax-subword-mode 1) ;; easy workings with camel case, snake case and pretty much anything else
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
(setq mouse-wheel-follow-mouse nil)
(setq scroll-step 1) ;;smooth-osh scrolling
(setq confirm-kill-emacs 'y-or-n-p) ;; Sometimes I fat finger C-x C-c
(setq save-interprogram-paste-before-kill t)
(global-auto-revert-mode 1) ;; see changes on disc as quick as possible 
(setq auto-revert-verbose nil) ;; everything is seemless
;;for good measures
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(require 'saveplace) ;; saves your cursor's position in buffers and jumps to it on reopening
(setq-default save-place t)
(setq save-place-file (locate-user-emacs-file "places" ".emacs-places"))
(setq save-place-forget-unreadable-files nil)
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
(define-key my-keys-mode-map (kbd "M-c") 'capitalize-dwim)
(setq vc-follow-symlinks t) ;; it asks you everytime otherwise
(define-key my-keys-mode-map (kbd "<f5>") 'revert-buffer)
(global-unset-key  ( kbd "<prior>"))
(global-unset-key  ( kbd "<next>"))
(define-key my-keys-mode-map (kbd "C-<prior>") 'scroll-down-line)
(define-key my-keys-mode-map (kbd "C-<next>") 'scroll-up-line)
#+END_SRC
** Copy line below
Use =Alt-up/down= as in any other editor to copy lines 
#+BEGIN_SRC emacs-lisp :results none
(defun duplicate-line-down()
  (interactive)
  (let ((saved-position (point)))
    (move-beginning-of-line 1)
    (kill-line)
    (yank)
    (open-line 1)
    (next-line 1)
    (yank)
    (goto-char saved-position)
    )
  )
(defun duplicate-line-up()
  (interactive)
  (let ((saved-position (point)))
    (move-beginning-of-line 1)
    (kill-line)
    (yank)
    (move-beginning-of-line 1)
    (open-line 1)
    (yank)
    (goto-char saved-position)
    (next-line 1)
    )
  )


(define-key my-keys-mode-map [(control shift down)]  'duplicate-line-down)
(define-key my-keys-mode-map [(control shift up)]  'duplicate-line-up) 
#+END_SRC
** Making parenthesis smart
Those are pretty much a must when editing code...and also anything else
- Select region and wrap it up with a sybol
  - Cofigured with the standards
  - Cofigured with the formating of =org-mode=
- Insert a opening bracecket and the closing is inserted automagically!
-[[https://github.com/rejeep/wrap-region.el][wrap-region]]
-[[https://github.com/Fuco1/smartparens][smartparens]]
#+BEGIN_SRC emacs-lisp
(require 'wrap-region)
(wrap-region-add-wrapper "=" "=")
(wrap-region-add-wrapper "/" "/")
(wrap-region-add-wrapper "_" "_")
(wrap-region-add-wrapper "+" "+")
(wrap-region-add-wrapper "*" "*")
(wrap-region-add-wrapper "~" "~")
(wrap-region-add-wrapper "$" "$")
(wrap-region-add-wrapper "<" ">")
(wrap-region-add-wrapper ">" "<")







(wrap-region-global-mode t)

(require 'smartparens)
(smartparens-global-mode 1)




#+END_SRC
** Bytecompiling everything
This function will bytecompile everything that it finds in the .emacs.d directory. This could boots the performance of emacs
#+BEGIN_SRC emacs-lisp
(defun byte-compile-init-dir ()
  "Byte-compile all your dotfiles."
  (interactive)
  (byte-recompile-directory user-emacs-directory 0))

(defun remove-elc-on-save ()
  "If you're saving an elisp file, likely the .elc is no longer valid."
  (add-hook 'after-save-hook
            (lambda ()
              (if (file-exists-p (concat buffer-file-name "c"))
                  (delete-file (concat buffer-file-name "c"))))
            nil
            t))

(add-hook 'emacs-lisp-mode-hook 'remove-elc-on-save)


#+END_SRC
** Custom key bindings(some of it!) 
#+BEGIN_SRC emacs-lisp

(define-key my-keys-mode-map (kbd "C-+") 'text-scale-increase)
(define-key my-keys-mode-map (kbd "C--") 'text-scale-decrease)
(define-key my-keys-mode-map (kbd "C-z") 'undo)
(define-key my-keys-mode-map (kbd "C-x r e") 'eval-region)
(define-key my-keys-mode-map (kbd "<f5>") 'revert-buffer)

#+END_SRC
* Org-mode
** Common settings
Org-mode is awesome not just for note taking but also for general text editing, formating and all and all just plain old /writting/. Therefore some basic org-mode configuration comes at handy when working with =.org= files (this .init file is written in org-mode so...yeah!!). The =org-bullets= makes the heading look pretty. I have couple of extra exporterrs for =.org= files that just make my life easier. 
#+BEGIN_SRC emacs-lisp
(require 'org-bullets)

(setq org-support-shift-select (quote always))
(setq org-startup-indented t)
(setq org-hide-leading-stars t)


(setq org-babel-python-command "~/anaconda3/bin/python3.6")        
(setq org-default-notes-file (concat org-directory "/notes.org"))  
(setq org-directory "~/Dropbox/orgfiles")                          
(setq org-export-html-postamble nil)                               
(setq org-startup-folded (quote overview))                         

(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
(custom-set-variables
 '(org-directory "~/Dropbox/orgfiles")
 '(org-default-notes-file (concat org-directory "/notes.org"))
 '(org-export-html-postamble nil)
 '(org-hide-leading-stars t)
 '(org-startup-folded (quote overview))
 '(org-startup-indented t)
 )

(define-key global-map "\C-ca" 'org-agenda)
(define-key global-map "\C-cc" 'org-capture)

(setq org-log-done 'time)

(setq org-latex-listings 'minted
      org-latex-packages-alist '(("" "minted"))
      org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

(setq org-pretty-entities t)

(setq org-export-babel-evaluate nil)

(setq org-export-with-smart-quotes t)

(setq org-enable-priority-commands nil)
#+END_SRC
The codeblocks should be formated with the native envinroment of the language
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-confirm-babel-evaluate nil
      org-edit-src-content-indentation 0)

#+END_SRC 
** Exporters
Some extra export backends for org-mode that come in handy.
- Beamer - for making those awesome-ish presentations
- twbs(Tweeter Bootstrap) - quickly make your org files look really pretty
- hugo - I use Hugo for blogging and the exporter allowes me to write every single content page in /org-mode/
- gfm (Github Flavored Markdown) - this makes writing /README.md/ files easy (i.e. writing them in org-mode)
#+BEGIN_SRC emacs-lisp
(require 'ox-beamer)
(require 'ox-twbs)
(require 'ox-hugo)
(require 'ox-gfm)


#+END_SRC
** Org-extras
#+BEGIN_SRC emacs-lisp :results none
;; (require 'ox-extra)
;; (ox-extras-activate '(ignore-headlines))

(defun org-remove-headlines (backend)
  "Remove headlines with :no_title: tag."
  (org-map-entries (lambda () (delete-region (point-at-bol) (point-at-eol)))
                   "no_title"))

(add-hook 'org-export-before-processing-hook #'org-remove-headlines)
#+END_SRC
** Capture
#+BEGIN_SRC emacs-lisp :results none
(setq org-reverse-note-order t)
(setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/Dropbox/orgfiles/todos/todos.org" "Captured TODOS")
         "* TODO %?\nAdded: %U\n" :prepend t :kill-buffer t)
        ("w" "Web" entry (file+headline "~/Dropbox/orgfiles/todos/todos.org" "Tasks")
         "* TODO %?\nAdded: %U\n" :prepend t :kill-buffer t)
        ("r" "Prog" entry (file+headline "~/Dropbox/orgfiles/todos/todos.org" "Tasks")
         "* TODO %?\nAdded: %U\n" :prepend t :kill-buffer t)
        ("i" "Idea" entry (file+headline "~/Dropbox/orgfiles/todos/todos.org" "Someday/Maybe")
         "* IDEA %?\nAdded: %U\n" :prepend t :kill-buffer t)
        ("h" "Home" entry (file+headline "~/Dropbox/orgfiles/todos/todos.org" "Home")
         "* TODO %?\nAdded: %U\n" :prepend t :kill-buffer t)
        )
      )
#+END_SRC
** Reveal.js
This style of presenting looks cool but I don't use it that much. Still, I want to have the possibility in my emacs. 
#+BEGIN_SRC emacs-lisp
(require 'ox-reveal)

(setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
(setq org-reveal-mathjax t)

(require 'htmlize)
#+END_SRC
** Babel Languages
- Source block with this line in the header:
#+BEGIN_EXAMPLE
dot :file ./img/example1.png :cmdline -Kdot -Tpng
#+END_EXAMPLE
will produce a graph-png at the end....it's awesome!

#+BEGIN_SRC emacs-lisp :results none
(org-babel-do-load-languages
 (quote org-babel-load-languages)
 (quote (
         (emacs-lisp . t)
         (java . t)
         (dot . t)
         (ditaa . t)
         (R . t)
         (python . t)
         (ruby . t)
         (gnuplot . t)
         (clojure . t)
         (shell . t)
         (ledger . t)
         (org . t)
         (plantuml . t)
         (latex . t))))
#+END_SRC
** Templates
#+BEGIN_SRC emacs-lisp :results none
;; More of those nice template expansion
  (add-to-list 'org-structure-template-alist '("A" "#+DATE: ?"))
  (add-to-list 'org-structure-template-alist '("C" "#+BEGIN_CENTER\n?\n#+END_CENTER\n"))
  (add-to-list 'org-structure-template-alist '("D" "#+DESCRIPTION: ?"))
  (add-to-list 'org-structure-template-alist '("E" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE\n"))
  (add-to-list 'org-structure-template-alist '("H" "#+LATEX_HEADER: ?"))
  (add-to-list 'org-structure-template-alist '("I" ":INTERLEAVE_PDF: ?"))
  (add-to-list 'org-structure-template-alist '("L" "#+BEGIN_LaTeX\n?\n#+END_LaTeX"))
  (add-to-list 'org-structure-template-alist '("M" "#+LATEX_HEADER: \\usepackage{minted}\n"))
  (add-to-list 'org-structure-template-alist '("N" "#+NAME: ?"))
  (add-to-list 'org-structure-template-alist '("P" "#+HTML_HEAD: <link rel=\"stylesheet\" type=\"text/css\" href=\"org.css\"/>\n"))
  (add-to-list 'org-structure-template-alist '("S" "#+SUBTITLE: ?"))
  (add-to-list 'org-structure-template-alist '("T" ":DRILL_CARD_TYPE: twosided"))
  (add-to-list 'org-structure-template-alist '("V" "#+BEGIN_VERSE\n?\n#+END_VERSE"))
  (add-to-list 'org-structure-template-alist '("X" "#+EXCLUDE_TAGS: reveal?"))
  (add-to-list 'org-structure-template-alist '("a" "#+AUTHOR: ?"))
  (add-to-list 'org-structure-template-alist '("c" "#+CAPTION: ?"))
  (add-to-list 'org-structure-template-alist '("d" "#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \\n:nil ^:t arch:headline\n#+OPTIONS: author:t email:nil e:t f:t inline:t creator:nil d:nil date:t\n#+OPTIONS: toc:nil num:nil tags:nil todo:nil p:nil pri:nil stat:nil c:nil d:nil\n#+LATEX_HEADER: \\usepackage[margin=2cm]{geometry}\n#+LANGUAGE: en\n\n#+REVEAL_TRANS: slide\n#+REVEAL_THEME: white\n"))
  (add-to-list 'org-structure-template-alist '("e" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist '("f" "#+TAGS: @?"))
  (add-to-list 'org-structure-template-alist '("h" "#+BEGIN_HTML\n?\n#+END_HTML\n"))
  (add-to-list 'org-structure-template-alist '("i" "#+INTERLEAVE_PDF: ?"))
  (add-to-list 'org-structure-template-alist '("k" "#+KEYWORDS: ?"))
  (add-to-list 'org-structure-template-alist '("l" "#+LABEL: ?"))
  (add-to-list 'org-structure-template-alist '("m" "#+BEGIN_SRC matlab\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist '("n" "#+BEGIN_NOTES\n?\n#+END_NOTES"))
  (add-to-list 'org-structure-template-alist '("o" "#+OPTIONS: ?"))
  (add-to-list 'org-structure-template-alist '("p" "#+BEGIN_SRC python\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist '("q" "#+BEGIN_QUOTE\n?\n#+END_QUOTE"))
  (add-to-list 'org-structure-template-alist '("r" ":PROPERTIES:\n?\n:END:"))
  (add-to-list 'org-structure-template-alist '("s" "#+BEGIN_SRC ?\n#+END_SRC\n"))
  (add-to-list 'org-structure-template-alist '("t" "#+TITLE: ?"))
  (add-to-list 'org-structure-template-alist '("v" "#+BEGIN_VERBATIM\n?\n#+END_VERBATIM"))

#+END_SRC
** Reloading
For some reasons I have to call this after I've /require/-d all the exporters' backends in order to make them available in the export dispatcher of /org-mode/.
#+BEGIN_SRC emacs-lisp
(require 'org)
(org-reload)

#+END_SRC
* Windowing
Couple of minor setups that make working with frames a little bit easier. In a lot of cases I just want to switch the position of two windows so there is handy function there. Also, navigating around windows can be a bit weird and slow with just using =C-x o= so =windmove= is set up to work with =C-c= and the arrow keys
#+BEGIN_SRC emacs-lisp
(defun transpose-windows (arg) ;; yes, I know, there is also a crux-function that does the exact same thing...still...!!!
  "Transpose the buffers shown in two windows."
  (interactive "p")
  (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
    (while (/= arg 0)
      (let ((this-win (window-buffer))
            (next-win (window-buffer (funcall selector))))
        (set-window-buffer (selected-window) next-win)
        (set-window-buffer (funcall selector) this-win)
        (select-window (funcall selector)))
      (setq arg (if (plusp arg) (1- arg) (1+ arg))))))

(define-key ctl-x-4-map (kbd "t") 'transpose-windows)

(define-key my-keys-mode-map (kbd "C-c <left>")  'windmove-left)
(define-key my-keys-mode-map (kbd "C-c <right>") 'windmove-right)
(define-key my-keys-mode-map (kbd "C-c <up>")    'windmove-up)
(define-key my-keys-mode-map (kbd "C-c <down>")  'windmove-down)


;; when working with two monitors this is really helpful
(require 'ace-window)
(define-key my-keys-mode-map (kbd "C-x o") 'ace-window)

#+END_SRC

* Better searching
=Isearch= is great but I have ever wanted a isearch on steroids...or something with helm infused isearch. =Swiper= is exaclty that. =Anzu= is a mode line tweak that displays the number of found things by isearch but not by swiper. Yes, I should probably fix that some time in the future.
- [[https://github.com/abo-abo/swiper][Swiper]]
- [[https://github.com/syohex/emacs-anzu][Anzu]]
\\
/Note:/ I do also sometimes use /helm-occur-from-isearch/ in order to find something. I still like to have different possablities while performing an action and picking the best one in each individual case.
\\
/Update/: I've switched back to *isearch* for now
#+BEGIN_SRC emacs-lisp

(setq search-whitespace-regexp ".*?")

(require 'swiper)
(define-key my-keys-mode-map (kbd "C-c M-s")  'swiper)
(define-key my-keys-mode-map (kbd "C-s")  'isearch-forward)





(require 'ivy)
(setq ivy-display-style (quote fancy))



(require 'anzu)
(global-anzu-mode +1)
(define-key isearch-mode-map [remap isearch-query-replace]  'anzu-isearch-query-replace)

#+END_SRC

* Helm goodies
The best and the most fully fledged completion engine for emacs IMO. I cannot be productive in my emacs without this. When you are in minibuffer and start typing, things just appear as you type, you can select multiple items, perform actions on all of the (example: open multiple files with single =C-x C-f=) and many more features that I should probalby use on more regular basis.
- [[https://github.com/emacs-helm/helm][helm]]
#+BEGIN_SRC emacs-lisp :results none
(require 'helm)
(require 'helm-config)


(setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
      helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
      helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
      helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
      helm-ff-file-name-history-use-recentf t
      helm-echo-input-in-header-line t)

(setq helm-buffers-fuzzy-matching t
      helm-recentf-fuzzy-match t)

(setq helm-semantic-fuzzy-match t
      helm-imenu-fuzzy-match    t)


(setq helm-M-x-fuzzy-match t)

(setq helm-exit-idle-delay 0)


(define-key my-keys-mode-map (kbd "C-x C-f") 'helm-find-files)  
(setq helm-autoresize-max-height 0)
(setq helm-autoresize-min-height 50)
(helm-autoresize-mode 1)
(define-key my-keys-mode-map (kbd "M-x") 'helm-M-x)
(define-key my-keys-mode-map (kbd "C-x b") 'helm-mini)
(define-key my-keys-mode-map (kbd "C-c b") 'helm-semantic-or-imenu)
(define-key my-keys-mode-map (kbd "M-s") 'helm-projectile-grep)


;;search and install apt packages through Emacs...crazy, I know!!!
(define-key my-keys-mode-map (kbd "C-x c C-a") 'helm-apt)
(define-key my-keys-mode-map (kbd "C-x c M-m") 'helm-complete-file-name-at-point)

(define-key my-keys-mode-map (kbd "C-x c C-s") 'helm-occur-from-isearch)

(define-key my-keys-mode-map (kbd "C-x r h") 'helm-register)


(helm-mode 1)
(helm-autoresize-mode 1)

#+END_SRC
* Avy
Navigate by searching for a letter on the screen and jumping to it. Useful for quick navigation and getting to places on the screen.
- [[https://github.com/abo-abo/avy][avy]]
#+BEGIN_SRC emacs-lisp
(require 'avy)
(define-key my-keys-mode-map (kbd "C-c C-f") 'avy-goto-char)
#+END_SRC
* Iy
Go to next CHAR which is similar to "f" and "t" in /vim/. To note is that I don't think that this package will remember the state of your mark when you make the jump. So if you have the expression =int funcName(int a, int b)=, the cursor is at the beginnign of the epxresison and you type =C-SPC C-c f (= you wno't mark everything till the =(=. Still useful though. 
- [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]]
#+BEGIN_SRC emacs-lisp
(require 'iy-go-to-char)
(define-key my-keys-mode-map (kbd "C-c f") 'iy-go-up-to-char)
(define-key my-keys-mode-map (kbd "C-c F") 'iy-go-up-to-char-backward)
#+END_SRC
* Company
Complete Anything! I am yet to find an effective setup that is as fast as well as feature rich. I've defined hooks for some of the major modes that I use so that I don't hold too many active backends at the start. A lot of times I found myself turning off company-mode because it just makes the typing slower at some moments. The ~company-idle-delay~ makes the automatic popup impossible so that I would have to call it manually through =M-m=. 
- [[http://company-mode.github.io/][company]]
#+BEGIN_SRC emacs-lisp :results none
(require 'company)

(setq company-minimum-prefix-length 2
      company-tooltip-align-annotations nil
      company-tooltip-flip-when-above nil
      company-idle-delay nil
      company-show-numbers nil
      company-echo-truncate-lines nil)

;; (require 'ycmd)
;; (require 'company-ycmd)
;; (set-variable 'ycmd-extra-conf-whitelist '("/home/arnaud//my_projects/*"))
;; (set-variable 'ycmd-server-command `("python2.7" ,(file-truename "~/code/ycmd/ycmd/")))
;; (company-ycmd-setup)

(setq company-frontends '(company-pseudo-tooltip-unless-just-one-frontend
                          ))


(setq company-backends '())

(setq company-backends nil)

(setq company-backends '(
                         company-capf          
                         company-files         
                         (
                          company-dabbrev-code 
                          company-gtags
                          company-etags
                          company-keywords
                          )
                         company-dabbrev
                         company-yasnippets
                         ))


(global-company-mode t)
(define-key my-keys-mode-map (kbd "M-m") 'company-complete)



(defun my/nxml-mode-hook ()
  (add-to-list 'company-backends 'company-nxml))
(add-hook 'prog-mode-hook 'my/nxml-mode-hook)

(defun my/prog-mode-hook ()
  (add-to-list 'company-backends 'company-keywords))
(add-hook 'prog-mode-hook 'my/prog-mode-hook)




(require 'company-meghanada)
(defun my/meghanada-mode-hook ()
  (add-to-list 'company-backends 'company-meghanada))

(add-hook 'meghanada-mode-hook 'my/meghanada-mode-hook)




(require' company-irony)
(defun my/irony-mode-hook ()
  (add-to-list 'company-backends 'company-irony))

(add-hook 'iorny-mode-hook 'my/irony-mode-hook)




#+END_SRC

#+RESULTS:
| my/irony-mode-hook |

* Themes
I often alternate between these two and can't really decide which is my favorite one. I depends on the day, I guess. In this case, better to gave them both at one place!
#+BEGIN_SRC emacs-lisp :results none

(setq custom-enabled-themes (quote (spacemacs-dark)))
(setq custom-safe-themes t)
(load-theme 'spacemacs-dark)

;; (load-theme 'monokai)
#+END_SRC
* Flycheck
Syntax error-checking on the fly(haha!) while working on code. It's conventient to avoid small errors that screw up yoour compilation and are just being anoying. 
- [[http://www.flycheck.org/en/latest/][flycheck]]
#+BEGIN_SRC emacs-lisp
(require 'flycheck)  
(global-flycheck-mode t)
#+END_SRC

* Python
I use Python a lot these days. Yet, my python setup in /Emacs/ is less than minimal. I don't know what to say to you. I guess emacs is that good with python by default. 
#+BEGIN_SRC emacs-lisp
(require 'company-jedi)
(add-hook 'python-mode-hook 'jedi:setup)

(defun my/python-mode-hook ()
  (add-to-list 'company-backends 'company-jedi))

(add-hook 'python-mode-hook 'my/python-mode-hook)
#+END_SRC  
* Yasnippet
One of the most useful packages that is pretty much a must for a emacs configuration. The package provides a whole bunch of very handy snippets for code/text/structures in almost all major modes of emacs. The default prefix for some of the yas functions is =C-c &= but this really doesn't work for me. Therefore I've defined custom keybindings for the important functions. Also, I write a lot in c++, so I often found myself in the situation where I first expand a ~std::vector~ and then I want to give it a type of ~std::sting~. Stacked snippets are my best friend when it comes to this problem.
- [[https://github.com/joaotavora/yasnippet][yasnippets]]
#+BEGIN_SRC emacs-lisp
(require 'yasnippet)
(require 'yasnippet-snippets)
(yas-global-mode 1)
(define-key my-keys-mode-map (kbd "C-c y n" ) 'yas/new-snippet)
(define-key my-keys-mode-map (kbd "C-c y v" ) 'yas/visit-snippet-file)
(define-key my-keys-mode-map (kbd "C-c y r" ) 'yas/reload-all)


(require 'helm-c-yasnippet)
(setq helm-yas-space-match-any-greedy t)
(define-key my-keys-mode-map (kbd "C-c y h") 'helm-yas-complete)

;; stacked snippets <3
(setq yas-triggers-in-field t)

#+END_SRC
* Misc packages
Those pacakges add some minor tweak to EMACS to make text editing easier.
- [[https://github.com/Malabarba/beacon][beacon]] - flashes your cursor after the cursor has been re-positioned.
- [[https://github.com/nflath/hungry-delete]] - deletes all of the white spaces that are 'on the way' after hitting /delete/ or /backspace/. It's weird at first but then you get use to it and kinda crave it and feel its lack if not there.
- [[https://github.com/magnars/expand-region.el][expand-region]] - kinda of a wannabe of that one vim functionality where you select everything between two braces with few simple strokes. This is more powerful but not that precise, to put it mildly. Not that it's not good. Just hit key binding and you can grow the region in both sides by 'semantic increments', whatever that's supposed to mean.
- 
#+BEGIN_SRC emacs-lisp

                                        ; flashes the cursor's line when you scroll
(require 'beacon)
(beacon-mode 1)


                                        ; deletes all the whitespace when you hit backspace or delete
(require 'hungry-delete)
(global-hungry-delete-mode)



                                        ; expand the marked region in semantic increments (negative prefix to reduce region)
(require 'expand-region)
(define-key my-keys-mode-map (kbd "C-c =") 'er/expand-region)


#+END_SRC
** CRUX
...is an abrabiation for /A Collection of Ridiculously Useful eXtensions for Emacs/, so yeah, pretty self-explenatory.
-[[https://github.com/bbatsov/crux][crux]]
#+BEGIN_SRC emacs-lisp
(require 'crux)

(define-key my-keys-mode-map (kbd "C-c o") 'crux-open-with)
(define-key my-keys-mode-map (kbd "C-c r") 'crux-rename-file-and-buffer)
(define-key my-keys-mode-map (kbd "C-c I") 'crux-find-user-init-file)
(define-key my-keys-mode-map (kbd "C-c S") 'crux-find-shell-init-file)
(define-key my-keys-mode-map (kbd "M-k") 'crux-kill-line-backwards)
(define-key my-keys-mode-map (kbd "C-c t") 'crux-visit-term-buffer)


#+END_SRC

* Folding code
A standard IDE feature that comes out of the box with emacs. Just a little tweak to give it nice keybindings. To note is that I use german QWERTZ keyboard so this won't work for all you QWERTY-Normies out there.
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'hs-minor-mode)
(define-key my-keys-mode-map (kbd "M-ü") 'hs-show-all)
(define-key my-keys-mode-map (kbd "C-M-ü") 'hs-hide-all)
(define-key my-keys-mode-map (kbd "C-ü") 'hs-toggle-hiding)
#+END_SRC
* C++
At my work I use this emacs-configuration for a lot of c++ programming. Yet, similar to other sections, the c++ tweaks are...pretty much nothing. Emacs is just that good with no special c++ tweaks.
/Note:/ At some time I plan to experiment with *[[https://github.com/cquery-project/cquery][cquery]]*
#+BEGIN_SRC emacs-lisp :results none
(require' irony)
(add-hook 'c++-mode-hook 'irony-mode)
(add-hook 'c-mode-hook 'irony-mode)
(add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

;; (require 'cquery)

;; (require 'cquery)
;; (setq cquery-executable "/home/arnaud/code/cquery/build/release/bin/cquery")
;; (setq cquery-extra-init-params '(:index (:comments 2) :cacheFormat "msgpack"))

#+END_SRC

* Programming
Surprisingly I don't have all that much tweaks in here. Commenting out regions or lines is probably the thing I use the most. The other things are just very minor things that are standard in every other IDE. 
- [[https://github.com/abo-abo/function-args][function-args]] - package that provies smart completion for function arguments. Works perfectly with *yasnippets*.
#+BEGIN_SRC emacs-lisp
(defun comment-or-uncomment-region-or-line ()
  "Comments or uncomments the region or the current line if there's no active region."
  (interactive)
  (save-excursion 
    (let (beg end)
      (if (region-active-p)
          (setq beg (region-beginning) end (region-end))
        (setq beg (line-beginning-position) end (line-end-position)))
      (comment-or-uncomment-region beg end))))

(define-key my-keys-mode-map (kbd "C-/") 'comment-or-uncomment-region-or-line)
(setq c-default-style
      '((java-mode . "java") (other . "awk")))
(setq-default c-default-style "awk")
(setq-default indent-tabs-mode nil)
(setq-default c-basic-offset 2)

(add-hook 'proge-mode-hook 'semmantic-highlight-func-mode)
(show-paren-mode 1)

(require 'function-args)
(fa-config-default)
(set-default 'semantic-case-fold t)
(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
(set-default 'semantic-case-fold t)

(add-hook 'c++-mode-hook 'function-args-mode)


#+END_SRC
* Text editing
** Alt-moving selection
Another 'standard feature' of most editors but in emacs we have to set it up because this is how we roll. This is just moving the selected block up and down while holding /Alt/
- [[https://github.com/rejeep/drag-stuff.el][drag-stuff]]
#+BEGIN_SRC emacs-lisp
(require 'drag-stuff)
(drag-stuff-global-mode)
(define-key my-keys-mode-map (kbd "M-<up>") 'drag-stuff-up)
(define-key my-keys-mode-map (kbd "M-<down>") 'drag-stuff-down)
#+END_SRC
* Web Mode
From time to time I ahave to write HTML and other 'web-stuff' and this setup gets me by. It's not really sophisticated and complex but.... come on, it web-programming...no offense. There are a lot Key bindings that come with =web-mode= that I don't really know, mostly because I don't use it that much but if you do, be sure to check them out.
- [[https://github.com/smihica/emmet-mode][emmet-mode]] - =C-j= Expands the emmet code given the minor mode is active 
#+BEGIN_SRC emacs-lisp
(require 'web-mode)
(add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.api\\'" . web-mode))
(add-to-list 'auto-mode-alist '("/some/react/path/.*\\.js[x]?\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))

(defun my-web-mode-hook ()
  "Hooks for Web mode."
  (setq web-mode-markup-indent-offset 2)

  (require 'emmet-mode)
  (emmet-mode 1)

  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2)
  (setq web-mode-style-padding 1)
  (setq web-mode-script-padding 1)
  (setq web-mode-block-padding 0)

  (setq web-mode-extra-auto-pairs
        '(("erb"  . (("beg" "end")))
          ("php"  . (("beg" "end")
                     ("beg" "end")))
          ))
  (setq web-mode-enable-auto-pairing t)
  (setq web-mode-enable-current-column-highlight t)


  (setq web-mode-ac-sources-alist
        '(("css" . (ac-source-css-property))
          ("html" . (ac-source-words-in-buffer ac-source-abbrev))))

  
  
  )
(add-hook 'web-mode-hook  'my-web-mode-hook)

#+END_SRC
* Projectile
The de-facto standard for project management for emacs. Not sure if I utilize half of its functionality but this file searching and opening...man that feels good when putting it to use. When in a project(which is just a git-repo btw) just type =C-c p f= and be blown away. When you we *helm* with *projectile*, we pretty much get one of the most powerful features in the history of IDEs ever. Some of my relevant keybindings include:
- =f4= - switch to other file. For working with /.cpp/ and /.hpp/ files
- =C-c p f= for finding files the easiest way possible.
- =C-c p d= for finding directories the easiest way possible.
- =M-s= helm-projectile-grep - really cool for searching a phrase of something in a entire project
- =C-c p 4 f= - find file and open it in another window
- =C-c p F= - find file in all known projects
- =C-c p 4 F= find file in all known projects and open it in another window
- =C-c p e= - see recent files
- =C-c p x s= run shell at the root of the project
- =C-c p S= save all files of the current project
----------------------------
Get it here -> [[https://github.com/bbatsov/projectile][PROJECTILE!!!]]
#+BEGIN_SRC emacs-lisp
 (require 'projectile)
 (projectile-global-mode)
 (setq projectile-completion-system 'helm)
 (define-key my-keys-mode-map [f4] 'projectile-find-other-file)
#+END_SRC
* Neotree
My tree browser of choice. Was blown away when I found that emacs has the ability to pull of something like tree browser. This was probably the functionality that showed me that emacs can be a substitute for every other IDE/text editor(on which the hippsters web-developers write their low level plebian 'web-apps')
- [[https://github.com/jaypei/emacs-neotree][neotree]]
#+BEGIN_SRC emacs-lisp
(require 'neotree)
(require 'all-the-icons)

(define-key my-keys-mode-map [f1] 'neotree-toggle)
(define-key my-keys-mode-map [f2] 'neotree-find)

(setq neo-window-width 40)
(setq neo-window-fixed-size nil)
(setq neo-theme (if (display-graphic-p) 'nerd 'arrow))
(setq neo-show-hidden-files t)
;;(setq projectile-switch-project-action 'neotree-projectile-action)


#+END_SRC
* PDF-Tools
Viewing pdf files in emacs! Not really intented for big and heavy files but when I have to check on something is does the trick.
- [[https://github.com/politza/pdf-tools][pdf-tools]]
#+BEGIN_SRC emacs-lisp
(require 'pdf-tools)
(require 'org-pdfview)
#+END_SRC

* Pretty startup screen
A dashboard(yeah, I know, pretend the name didn't say it) kind of thing that display on startup of/Emacs/ and gives quick access to recent files and projectile-projects. It works with sessions too but I haven't configured that yet. A image can also be displayed so I guess that is pretty. Custom startup message is a must of course!!
- [[https://github.com/rakanalh/emacs-dashboard][dashboard]]
#+BEGIN_SRC emacs-lisp

(require 'dashboard)

(setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
(setq dashboard-banner-logo-title "Welcome to the Emacs of Stanislav Arnaudov")
(setq dashboard-startup-banner 'official)
(setq dashboard-items '((recents  . 10)
                        (bookmarks . 5)
                        (projects . 10)
                        (agenda . 5)
                        (registers . 5)))
(dashboard-setup-startup-hook)


#+END_SRC
* Sessios persistence
Sometimes it gets really annoying when I close my emacs and have a bunch of buffers opened, the next time I launch the program, the buffers are gone and I have to open them again. Mind-blowing, I know, "So why do you close emacs?" - shut up, that's not the point . This package addresses my issues. I can even have custom sessions and open whole groups of tabs all at once
From the documentation:
#+BEGIN_EXAMPLE
<prefix> <key>
<prefix> c    - create workgroup
<prefix> A    - rename workgroup
<prefix> k    - kill workgroup
<prefix> v    - switch to workgroup
<prefix> C-s  - save session
<prefix> C-f  - load session
#+END_EXAMPLE
(kinda like cheat sheet)
---------
- [[https://github.com/pashinin/workgroups2][workgroups2]]
#+BEGIN_SRC emacs-lisp :results none
(require 'workgroups2)
(workgroups-mode 1)  

(setq wg-prefix-key (kbd "C-c z"))
(setq wg-session-file "~/.emacs.d/.emacs_workgroups")
(setq wg-emacs-exit-save-behavior           'save)    
(setq wg-workgroups-mode-exit-save-behavior 'save)
(setq wg-mode-line-display-on t)          
(setq wg-flag-modified t)
(setq wg-mode-line-decor-left-brace "["
      wg-mode-line-decor-right-brace "]"
      wg-mode-line-decor-divider ":")
#+END_SRC

* Java
I don't really use EMACS for java development as it can be tedious and the packages are not really on part with some other modern IDEs (like Netbeans ;) ). Still, I do have some basic setup for =meghanada= to make my life easier if I have to edit some java program really quick through emacs.
- [[https://github.com/mopemope/meghanada-emacs][meghanada]] 
#+BEGIN_SRC emacs-lisp
(require 'meghanada)
(add-hook 'java-mode-hook
          (lambda ()
            (meghanada-mode t)
            (flycheck-mode +1)
            (setq c-basic-offset 2)
            (add-hook 'before-save-hook 'meghanada-code-beautify-before-save)))
(cond
   ((eq system-type 'windows-nt)
    (setq meghanada-java-path (expand-file-name "bin/java.exe" (getenv "JAVA_HOME")))
    (setq meghanada-maven-path "mvn.cmd"))
   (t
    (setq meghanada-java-path "java")
    (setq meghanada-maven-path "mvn")))


#+END_SRC
* Markdown
Markdown is not as pretty as Org-mode but is widely used throughout the Internet. I often have to open /.md/ files and therefore it's woorth making them look pretty in my emacs. The =markdown-mode= provies exaclty that.
-[[https://jblevins.org/projects/markdown-mode/][markdown-mode]]
#+BEGIN_SRC emacs-lisp
(autoload 'markdown-mode "markdown-mode"
   "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.text\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.txt\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode))
#+END_SRC
* IBuffer
This package makes your =C-x C-b= (/list-buffers/) pretty. You can even specify custom sections where the buffers are to be put depending on certain conditions - name, mode, etc. There is also projectile integration but I don't find that very useful. I like the buffers grouped in small more groups.
- [[https://www.emacswiki.org/emacs/IbufferMode][ibuffer]]
#+BEGIN_SRC emacs-lisp :results none
(require 'ibuffer)
(require 'ibuffer-projectile)
(define-key my-keys-mode-map (kbd "C-x C-b") 'ibuffer)
;;(autoload 'ibuffer "ibuffer" "List buffers." t)
(setq ibuffer-expert t)
(setq ibuffer-show-empty-filter-groups nil)


(setq ibuffer-saved-filter-groups
      '(
        ("home"
	 ("Emacs-config" (or (filename . ".emacs")
			     (filename . "myinit.org")))
         ("Org" (or (mode . org-mode)
		    (filename . "OrgMode")))
         ("Programming C++" 
          (or
           (mode . c-mode)
           (mode . c++-mode)
           ))

         ("Source Code"
          (or
           (mode . python-mode)
           (mode . emacs-lisp-mode)
           (mode . shell-script-mode)
           (mode . json-mode)
           ;; etc
           ))
         ("Sripts"
          (name . ".sh")
          )
         ("Documents"
          (mode . doctex-mode)
          )
         ("LaTeX"
          (or
           (mode . tex-mode)
           (mode . latex-mode)
           (name . ".tex")
           (name . ".bib")
           ))

         ("Text" (name . ".txt"))
         ("JS" (mode . "javascript-mode"))
         ("Web Dev" (or (mode . html-mode)
			(mode . css-mode)
                        (mode . webmode-mode)))
         ("Emacs-created"
          (or
           (name . "^\\*")))
         )))


;;(add-hook 'ibuffer-hook
;;          (lambda ()
;;          (ibuffer-projectile-set-filter-groups)
;;            (unless (eq ibuffer-sorting-mode 'alphabetic)
;;              (ibuffer-do-sort-by-alphabetic))))


(add-hook 'ibuffer-mode-hook
	  '(lambda ()
	     (ibuffer-auto-mode 1)
	     (ibuffer-switch-to-saved-filter-groups "home")))



;;(require 'ibuf-ext)
;;(add-to-list 'ibuffer-never-show-predicates "^\\*")

#+END_SRC

#+RESULTS:
| lambda | nil | (ibuffer-auto-mode 1) | (ibuffer-switch-to-saved-filter-groups home) |

----------------------
* Shell
My choice of terminal envinroment in my emacs is /Terminal Emulator/(term). There are two modes to it - /char/ and /line/. Switching between them is made easier with one simple function and some custom key-bindings.
//
 May other IDEs use =F5= for building and compiling projects and I've gotten used to that. Therefore...custom keybinding.
#+BEGIN_SRC emacs-lisp
(require 'term)

(define-key my-keys-mode-map [f3] 'term)

(defun my/term-toggle-mode ()
  "Toggles term between line mode and char mode"
  (interactive)
  (if (term-in-line-mode)
      (term-char-mode)
    (term-line-mode)))

(define-key term-mode-map (kbd "C-c C-j") 'my/term-toggle-mode)
(define-key term-mode-map (kbd "C-c C-k") 'my/term-toggle-mode)
(define-key term-raw-map (kbd "C-c C-j") 'my/term-toggle-mode)
(define-key term-raw-map (kbd "C-c C-k") 'my/term-toggle-mode)
(define-key my-keys-mode-map (kbd "C-<f5>") 'compile)



#+END_SRC

* Org-Babel
For some reason I must set the right /python/ command each time I start emacs. This does the trick...sometimes. Running random snippets of code in /.org/ files...how bonkers is that. The answer is *pretty bonkers*!!(You know if you are into emacs if you get this "reference")
#+BEGIN_SRC emacs-lisp
(setq org-babel-python-command "~/anaconda3/bin/python3.6")
#+END_SRC
* Spellchecking
Yes, I am a hirroble speller. Thank god that there are tools that help me live my miserable uneducated life. I often have to write in german too so I have custom dictionary switching key-binding. Other than that, I find =C-c s= to be most intuitive for correcting misspelled words. *flyspell-popup* is a handy little thing that is pretty much company for showing a list of possible *correct* words.
[[https://github.com/xuchunyang/flyspell-popup][flyspell-popup]]
#+BEGIN_SRC emacs-lisp
(require 'flyspell)
(define-key flyspell-mode-map (kbd "C-c s") #'flyspell-popup-correct)

;,(add-hook 'flyspell-mode-hook #'flyspell-popup-auto-correct-mode)

(defun fd-switch-dictionary()
  (interactive)
  (let* ((dic ispell-current-dictionary)
    	 (change (if (string= dic "deutsch8") "english" "deutsch8")))
    (ispell-change-dictionary change)
    (message "Dictionary switched from %s to %s" dic change)
    ))

(define-key my-keys-mode-map (kbd "<f8>")   'fd-switch-dictionary)

#+END_SRC
* Google This
This is absolutely a genius thing! Mark something, simple key-stroke, BAM!! Google! You are there! You have no idea how much copying and windows switching this package saves. Again, for intuition sake, =C-c g= is the prefix. After that:
- =w= for word
- =s= for selection
- =g= for googling from prompted input
- =SPC= for region
- =l= for line
- =c= for cpp-reference

I also frequanlty use Zeal. It's an application housing tons of usefull documentations and look ups in it while working on somethings are a must. Therefore I have package named *zeal-at-point* that allows me to perform quick search actions in the application with query take form the point. The keybinding for that is =C-c g z= (*Z*eal).
-------------------
- [[https://github.com/Malabarba/emacs-google-this][google-this]]
- [[https://github.com/jinzhu/zeal-at-point][zeal-at-point]]
#+BEGIN_SRC emacs-lisp



(require 'google-this)
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "firefox")
(google-this-mode 1)
(define-key my-keys-mode-map (kbd "C-c g") 'google-this-mode-submap)
(define-key my-keys-mode-map (kbd "C-c g c") 'google-this-cpp-reference)


(define-key my-keys-mode-map (kbd "C-c g z ") 'zeal-at-point)


#+END_SRC
* Cmake
A minimal Cmake setup, more or less to make my /CMakeLists.txt/ files pleasant to the eyes. I don't really need more as I don't spend that much time writing /cmake/ scripts.
#+BEGIN_SRC emacs-lisp
(require 'cmake-mode)
(require 'company-cmake)

(defun my/cmake-mode-hook ()
  (add-to-list 'company-backends 'company-cmake))
(add-hook 'cmake-mode-hook 'my/cmake-mode-hook)

(setq cmake-tab-width 4)

(setq auto-mode-alist
      (append '(("CMakeLists\\.txt\\'" . cmake-mode)
                ("\\.cmake\\'" . cmake-mode))
              auto-mode-alist))
#+END_SRC
* Latex
I used to use [[http://www.xm1math.net/texmaker/TexMaker/][/TexMaker/]] for writing my $\LaTeX$ documents but recent changes to its interface have made me look for alternative. Also, recent changes with me and me loving /Emacs/ have made the choice pretty easy. By know I don't think I miss anything that /TexMaker/ could offer me that /Emacs/ cannot.
- [[https://www.emacswiki.org/emacs/AUCTeX][auctex]] - full fledged environment for writing, editing and compiling /.tex/ documents. Almost everything comes out of the box. Only a simple setup and configuration is required. 
- [[https://www.emacswiki.org/emacs/LaTeXPreviewPane][latex-preview-pane]] - The very cool feature of Tex/Maker/ where your generated /pdf/-document is displayed on the side. Yes. Emacs can do it too...surprise, surprise!!
#+BEGIN_SRC emacs-lisp :results none
(require 'tex)


(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq-default TeX-master nil)

(add-hook 'LaTeX-mode-hook 'visual-line-mode)
(add-hook 'LaTeX-mode-hook 'flyspell-mode)
(add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
(add-hook 'LaTeX-mode-hook 'pretty-mode)
(add-hook 'LaTeX-mode-hook 'prettify-symbols-mode)

(defun my/latex-mode-hook ()
  (add-to-list 'company-backends 'company-auctex-bibs)
  (add-to-list 'company-backends 'company-auctex-macros)
  (add-to-list 'company-backends 'company-auctex-labels)
  (add-to-list 'company-backends 'company-auctex-symbols)
  (add-to-list 'company-backends 'company-auctex-environments)
  )
(add-hook 'cmake-mode-hook 'my/latex-mode-hook)

(add-hook 'LaTeX-mode-hook 'turn-on-reftex)
(setq reftex-plug-into-AUCTeX t)

(TeX-global-PDF-mode t)

(require 'latex-preview-pane)
(define-key my-keys-mode-map (kbd "C-c l p") 'latex-preview-pane-mode)

#+END_SRC
* Vim like killing and yanking
Not exactly what the heading suggests but I've recently learned some vim keybindings and *my god* those get things done fast. Emacs is kind of lacking on this end, but you know what they say
#+BEGIN_QUOTE
Emacs is a nice Operating System but it lacks decent editor
--- Someone big in the Emacs Community
#+END_QUOTE
This package adds some handy functionality to =M-w=. Basically, after the initial command, through key strokes one can select very precisely-ish what is to be put in the kill ring.
- [[https://github.com/leoliu/easy-kill][easy-kill]]
#+BEGIN_SRC emacs-lisp
(require 'easy-kill)
(define-key my-keys-mode-map [remap kill-ring-save] 'easy-kill)
#+END_SRC
* Aggressive Indent
When writing code I lot of times I mark the things I've just typed and hit /Tab/ to indent it properly. This packages help me not to do that so often as it indents things right before your eyes in the moment you write them. It gets annoying at times but you get used to it pretty quickly.
- [[https://github.com/Malabarba/aggressive-indent-mode][agrssive-indent]]
#+BEGIN_SRC emacs-lisp :results none
(require 'aggressive-indent)
(global-aggressive-indent-mode 1)
(add-to-list 'aggressive-indent-excluded-modes 'html-mode)
(add-to-list
 'aggressive-indent-dont-indent-if
 '(and (derived-mode-p 'c++-mode)
       (null (string-match "\\([;{}]\\|\\b\\(if\\|for\\|while\\)\\b\\)"
                           (thing-at-point 'line)))))
#+END_SRC
* Modline
Making the modeline a little bit prettier and more spece efficient than the default. =smart-mode-line= is the "main" package and =telephone-line= is there just to make the separators nicer.
  - [[https://github.com/dbordak/telephone-line][telephone-line]]
  - [[https://github.com/Malabarba/smart-mode-line][smart-mode-line]]
 Preview:
[[../mode-line.png]]
#+BEGIN_SRC emacs-lisp :results none
(require 'telephone-line)
(telephone-line-mode 1)

(require 'powerline)
(powerline-revert)
(powerline-center-theme)

;; (setq sml/no-confirm-load-theme t)
;; (sml/setup)
;; (setq sml/theme 'automatic)
#+END_SRC
* Sexp on steroids
As previously stated, I know tiny bit of vim key-bindings and holy cow those can do a lot of things in very few keystrokes. Emacs is not really like that. I've written some simple functions thal with saving, marking and killing /sexp/s. I really like that feature of vim "*d*elete *i*nside *(*-block" and it kills everything inside the parentesies....or copies it into kill ring or marks it, basically - it's pretty awesome and here I am trying to ripp off exxaclty that.\\
The commands that come in handy a lot of the times and that I've written:

| Keystroke   | Description                                              |
|-------------+----------------------------------------------------------|
| =C-M-k=     | Kill erverything inside the current /sexp/               |
| =C-M-K=     | Kill the current /sexp/ and the                          |
| =C-M-SPC=   | Mark erverything inside the current /sexp/               |
| =C-M-S-SPC= | Mar the current /sexp/                                   |
| =C-M-w=     | Save everything inside the current /sexp/ into kill ring |
| =C-M-W=     | Save the current /sexp/ into kill ring                   |
|-------------+----------------------------------------------------------|

As you've probably noticed =C-M= in like kind of a prefix for all /sexp/-operations

#+BEGIN_SRC emacs-lisp :results none

;; (require 'load-directory)
;; (load-directory "~/.emacs.d/my-lisp")

(load "~/.emacs.d/lisp/arnaud-sexp") 
(require 'arnaud-sexp)

(define-key my-keys-mode-map (kbd "C-M-SPC") 'arnaud-mark-sexp)
(define-key my-keys-mode-map (kbd "C-M-k") 'arnaud-kill-sexp)
(define-key my-keys-mode-map (kbd "C-M-S-SPC") 'arnaud-mark-sexp-whole)
(define-key my-keys-mode-map (kbd "C-M-S-k") 'arnaud-kill-sexp-whole)
(define-key my-keys-mode-map (kbd "C-M-w") 'arnaud-kill-save-sexp)
(define-key my-keys-mode-map (kbd "C-M-S-w") 'arnaud-kill-save-sexp-whole)
#+END_SRC
* Hydra
/Hydra/ is a package that allows you to create hydras. Those are like munues with keybindings that popout on the bottom of the buffer and prompt you to type one(or more) of the listed keybindings. This provides really cool way of structuring commands in a menu-like fashion. There are some predifined hydras that come with the package but those are not that good and therefore I've 'borrowed' a few from the mighty internet.
\\
=C-c h= is like the prefix for all my hydras. After that comes another letter (or /C-letter/) that selects the desired hydra.
|------------------+--------------------|
| Keybinding       | Hydra              |
|------------------+--------------------|
| =<prefix> b=     | Bookmarks          |
| =<prefix> r=     | Rectangle          |
| =<prefix> R=     | Registers          |
| =<prefix> C-o m= | Org Tress movement |
| =<prefix> C-o t= | Org Templates      |
| =<prefix> f=     | Formating          |
| =<prefix> p=     | Projectile         |
| =<prefix> M=     | Modes              |
| =<prefix> m=     | Magit              |
|------------------+--------------------|

There is also a 'special' Hydra that lists all other hydras and it's bound to =C-c h h=
-------------------
 - [[https://github.com/abo-abo/hydra][hydra]]

#+BEGIN_SRC emacs-lisp :results none
(require 'hydra)
(require 'hydra-examples)
#+END_SRC

** Windowing
#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-windowing (:color blue
                               :hint nil)
  "
 ^Ace-window^                        ^^
^^^^------------------------------------------------------------------
^ _s_: Select window^           ^ _o_: Ace^
^ _d_: Delete window^           
^ _m_: Maximize window^         
^ _c_: Close other windows^    
^ _t_: Transpose windows^       

"
  ("s" ace-select-window)
  ("d" ace-delete-window)
  ("m" ace-maximize-window)
  ("c" ace-delete-other-windows)
  ("t" ace-swap-windows)
  ("o" ace-window)
  ("q" nil :color blue))

(define-key my-keys-mode-map (kbd "C-c h w") 'arnaud-hydra-windowing/body)
#+END_SRC
** Bookmarks navigation
#+BEGIN_SRC emacs-lisp
(defhydra arnaud-hydra-bookmarks (:color blue
                              :hint nil)
  "
 _s_: set  _b_: bookmark   _j_: jump   _d_: delete   _q_: quit
  "
  ("s" bookmark-set)
  ("b" bookmark-save)
  ("j" bookmark-jump)
  ("d" bookmark-delete)
  ("q" nil :color blue))
(define-key my-keys-mode-map (kbd "C-c h b") 'arnaud-hydra-bookmarks/body)
#+END_SRC

** Editing rectangle
#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-rectangle (:pre (rectangle-mark-mode 1)
                                   :color blue
                                   :hint nil)
  "
 _p_: paste   _r_: replace  _I_: insert
 _y_: copy    _o_: open     _V_: reset
 _d_: kill    _n_: number   _q_: quit
"
  ("h" backward-char nil)
  ("l" forward-char nil)
  ("k" previous-line nil)
  ("j" next-line nil)
  ("y" copy-rectangle-as-kill)
  ("d" kill-rectangle)
  ("x" clear-rectangle)
  ("o" open-rectangle)
  ("p" yank-rectangle)
  ("r" string-rectangle)
  ("n" rectangle-number-lines)
  ("I" string-insert-rectangle)
  ("V" (if (region-active-p)
           (deactivate-mark)
         (rectangle-mark-mode 1)) nil)
  ("q" keyboard-quit :color blue))

(define-key my-keys-mode-map (kbd "C-c h r") 'arnaud-hydra-rectangle/body)
#+END_SRC
** Registers
#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-registers (:color blue
                              :hint nil)
  "
 _a_: append     _c_: copy-to    _j_: jump            _r_: rectangle-copy   _q_: quit
 _i_: insert     _n_: number-to  _f_: frameset        _w_: window-config
 _+_: increment  _p_: point-to   _h_: helm-register
  "
  ("a" append-to-register)
  ("c" copy-to-register)
  ("i" insert-register)
  ("f" frameset-to-register)
  ("j" jump-to-register)
  ("n" number-to-register)
  ("r" copy-rectangle-to-register)
  ("w" window-configuration-to-register)
  ("+" increment-register)
  ("p" point-to-register)
  ("h" helm-register)
  ("q" nil :color blue))
(define-key my-keys-mode-map (kbd "C-c h R") 'arnaud-hydra-registers/body)
#+END_SRC
** Modes toggling
#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-active-modes (:color red
                                       :hint nil)
  "
 _b_: fancy battery   _C-c_: flycheck       _c_: company     _j_: jedi
 _l_: linenum         _v_: visual-line      _h_: hs-minor   
 _f_: flyspell        _y_: yas              _e_: emmet       _q_: quit
"
  ("b" fancy-battery-mode)
  ("l" global-nlinum-mode)
  ("f" flyspell-mode)
  ("C-c" global-flycheck-mode)
  ("v" visual-line-mode)
  ("y" yas-global-mode)
  ("c" company-mode)
  ("h" hs-minor-mode)
  ("e" emmet-mode)
  ("j" jedi-mode)
  ("q" nil :color blue))


(define-key my-keys-mode-map (kbd "C-c h M") 'arnaud-hydra-active-modes/body)
#+END_SRC
** Org trees movement
#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-org-organize (:color red
                                            :hint nil)
  "
       ^Meta^                 
^^--------------------------------------------------------------------
      ^ _<up>_ ^          _q_: quit
 _<right>_ ^+^ _<left>_
      ^_<down>_^      
"
  ("<left>" org-metaleft)
  ("<right>" org-metaright)
  ("<down>" org-metadown)
  ("<up>" org-metaup)
  ("q" nil :color blue))

(define-key my-keys-mode-map (kbd "C-c h C-o m") 'arnaud-hydra-org-organize/body)
#+END_SRC
** Org templates expansions
#+BEGIN_SRC emacs-lisp :results none
(defun hot-expand (str)
  "Expand org template."
  (insert str)
  (org-try-structure-completion))

(defhydra arnaud-hydra-org-template (:color blue
                                 :hint nil)
  "
 ^One liners^                                        ^Blocks^                                      ^Properties^
--------------------------------------------------------------------------------------------------------------------------------------------------------
 _a_: author        _i_: interleave  _D_: description    _C_: center      _p_: python src    _n_: notes    _d_: defaults   _r_: properties        _<_: insert '<'
 _A_: date          _l_: label       _S_: subtitle       _e_: elisp src   _Q_: quote                     _L_: latex      _I_: interleave        _q_: quit
 _c_: caption       _N_: name        _k_: keywords       _E_: example     _s_: src                       _x_: export     _T_: drill two-sided
 _f_: file tags     _o_: options     _M_: minted         _h_: html        _v_: verbatim                  _X_: noexport
 _H_: latex header  _t_: title       _P_: publish        _m_: matlab src  _V_: verse
 "
  ("a" (hot-expand "<a"))
  ("A" (hot-expand "<A"))
  ("c" (hot-expand "<c"))
  ("f" (hot-expand "<f"))
  ("H" (hot-expand "<H"))
  ("i" (hot-expand "<i"))
  ("I" (hot-expand "<I"))
  ("l" (hot-expand "<l"))
  ("n" (hot-expand "<n"))
  ("N" (hot-expand "<N"))
  ("P" (hot-expand "<P"))
  ("o" (hot-expand "<o"))
  ("t" (hot-expand "<t"))
  ("C" (hot-expand "<C"))
  ("D" (hot-expand "<D"))
  ("e" (hot-expand "<e"))
  ("E" (hot-expand "<E"))
  ("h" (hot-expand "<h"))
  ("k" (hot-expand "<k"))
  ("M" (hot-expand "<M"))
  ("m" (hot-expand "<m"))
  ("p" (hot-expand "<p"))
  ("Q" (hot-expand "<q"))
  ("s" (hot-expand "<s"))
  ("S" (hot-expand "<S"))
  ("v" (hot-expand "<v"))
  ("V" (hot-expand "<V"))
  ("x" (hot-expand "<x"))
  ("X" (hot-expand "<X"))
  ("d" (hot-expand "<d"))
  ("L" (hot-expand "<L"))
  ("r" (hot-expand "<r"))
  ("I" (hot-expand "<I"))
  ("T" (hot-expand "<T"))
  ("b" (hot-expand "<b"))
  ("<" self-insert-command)
  ("q" nil :color blue))

(define-key my-keys-mode-map (kbd "C-c h C-o t") 'arnaud-hydra-org-template/body)
#+END_SRC
** Formatting
#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-format (:color blue
                               :hint nil)
  "
 ^Beautify^
^^^^^^^^^^--------------------------------------
 _h_: html        _c_: css       _j_: js        _q_: quit
 _H_: html buf    _C_: css buf   _J_: js buf
"
  ("h" web-beautify-html)
  ("H" web-beautify-html-buffer)
  ("c" web-beautify-css)
  ("C" web-beautify-css-buffer)
  ("j" web-beautify-js)
  ("J" web-beautify-js-buffer)
  ("q" nil :color blue))
(define-key my-keys-mode-map (kbd "C-c h f") 'arnaud-hydra-format/body)
#+END_SRC
** Projectile
#+BEGIN_SRC emacs-lisp :results none
(defhydra hydra-projectile-other-window (:color teal)
  "projectile-other-window"
  ("f"  projectile-find-file-other-window        "file")
  ("g"  projectile-find-file-dwim-other-window   "file dwim")
  ("d"  projectile-find-dir-other-window         "dir")
  ("b"  projectile-switch-to-buffer-other-window "buffer")
  ("q"  nil                                      "cancel" :color blue))

(defhydra arnaud-hydra-projectile (:color teal :hint nil)
  "
     PROJECTILE: %(projectile-project-root)

     Find File            Search/Tags          Buffers                Cache
------------------------------------------------------------------------------------------
_s-f_: file            _a_: ag                _i_: Ibuffer           _c_: cache clear
 _ff_: file dwim       _g_: update gtags      _b_: switch to buffer  _x_: remove known project
 _fd_: file curr dir   _o_: multi-occur     _s-k_: Kill all buffers  _X_: cleanup non-existing
  _r_: recent file                                               ^^^^_z_: cache current
  _d_: dir

"
  ("<ESC>" nil "quit")
  ("<" hydra-project/body "back")
  ("a"   projectile-ag)
  ("b"   projectile-switch-to-buffer)
  ("c"   projectile-invalidate-cache)
  ("d"   projectile-find-dir)
  ("s-f" projectile-find-file)
  ("ff"  projectile-find-file-dwim)
  ("fd"  projectile-find-file-in-directory)
  ("g"   ggtags-update-tags)
  ("s-g" ggtags-update-tags)
  ("i"   projectile-ibuffer)
  ("K"   projectile-kill-buffers)
  ("s-k" projectile-kill-buffers)
  ("m"   projectile-multi-occur)
  ("o"   projectile-multi-occur)
  ("s-p" projectile-switch-project "switch project")
  ("p"   projectile-switch-project)
  ("s"   projectile-switch-project)
  ("r"   projectile-recentf)
  ("x"   projectile-remove-known-project)
  ("X"   projectile-cleanup-known-projects)
  ("z"   projectile-cache-current-file)
  ("`"   hydra-projectile-other-window/body "other window" :color blue)
  ("q"   nil "cancel" :color blue))

(define-key my-keys-mode-map (kbd "C-c h p") 'arnaud-hydra-projectile/body)
#+END_SRC
** Magit

#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-magit (:color blue :hint nil)
  "
      Magit: %(magit-get \"remote\" \"origin\" \"url\")

 ^Status^      ^Remote^          ^Operations^
^^^^^^------------------------------------------------------------------------------------------
_s_: Status      _f_: Pull       _c_  : Commit
_l_: Log all     _p_: Push       _C-s_: Stage 
_d_: Diff        _C-c_: Clone    _S_  : Stage modified
 ^^                 ^^           ^_C-f_: Stage file^
 ^^                 ^^           ^_M-f_: Unstage file^
"
  ("f" magit-pull)
  ("p" magit-push)
  ("c" magit-commit)
  ("C-c" magit-clone)
  ("d" magit-diff)
  ("l" magit-log-all )
  ("s" magit-status)
  ("C-s" magit-stage)
  ("C-f" magit-stage-file)
  ("M-f" magit-unstage-file)
  ("S" magit-stage-modified)
  ("q" nil "Cancel" :color blue))



(define-key my-keys-mode-map (kbd "C-c h m") 'arnaud-hydra-magit/body)
#+END_SRC
** Hydras
#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-magit (:color teal :hint nil)
"
    ^^                    ^Available Hydras^             ^^
^^^^^^------------------------------------------------------------------------
^_w_^ : Windowing    ^_R_^     : Registers            ^_f_^ : Formating
^_b_^ : Bookmarks    ^_M_ ^    : Modes                ^_p_^ : Projectile
^_r_^ : Rectangle    ^_C-o m_^ : Org treee move       ^_m_^ : Magit
^_l_^ : LaTeX        ^_C-o t_^ : Org templates             ^^
    
"
  ("w" arnaud-hydra-windowing/body)
  ("b" arnaud-hydra-bookmarks/body)
  ("r" arnaud-hydra-rectangle/body)
  ("R" arnaud-hydra-registers/body)
  ("M" arnaud-hydra-modes/body)
  ("C-o m" arnaud-hydra-org-organize/body)
  ("C-o t" arnaud-hydra-org-template/body)
  ("f" arnaud-hydra-formating/body)
  ("p" arnaud-hydra-projectile/body)
  ("m" arnaud-hydra-magit/body)
  ("l" arnaud-hydra-latex/body)
  ("q" nil "Cancel" :color blue))

(define-key my-keys-mode-map (kbd "C-c h h") 'arnaud-hydra-magit/body)
#+END_SRC

* Things that need to be done in the dot-files                     :no_export:
Don't look at that, it's not for you!!!
** DONE Configure better web-mode support
CLOSED: [2018-05-02 Wed 12:53]
Is done in the config file that we use at work
** DONE Set up the key bindings for =avy=
CLOSED: [2018-05-07 Mon 16:50]
could be *REALLY* usefule
** DONE Move all the repos in one place
CLOSED: [2018-05-01 Tue 23:00]
** DONE Clean the /.emacs/ file
CLOSED: [2018-05-01 Tue 23:02]
It's pretty good now
** DONE Upload the file to a repo
CLOSED: [2018-05-01 Tue 23:03]
If you are reading this and you are not me....well, then I guess is to be marked as /DONE/!
** DONE Make an archive with the .emacs.d directory
CLOSED: [2018-05-01 Tue 23:03]
Some files of it at least!
** DONE Add annotations for everything
CLOSED: [2018-06-07 Thu 21:35]
** DONE Anotate the Hydra setup(s)
CLOSED: [2018-06-17 Sun 19:42]
** TODO Create Hydra for the latex mode things
** TODO Steal someone's python setup
** TODO Steal someone's c++ setup
** TODO Put the whole thing on the blog   
* Nonsense                                                         :no_export:
Put the whole whoel world on your table and pray for it!
#+BEGIN_SRC emacs-lisp
#+END_SRC

