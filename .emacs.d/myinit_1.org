#+startup: overview

#+title: Configuration file for my EMACS
#+AUTHOR: Stanislav Arnaudov
#+DATE: 18-04-2018
#+EMAIL: stanislav_ts@abv.bg
#+LANGUAGE: En
#+EXPORT_FILE_NAME: EMACS.md
#+CREATOR: Emacs 24.3.50.3 (Org mode 8.0.3)
#+SELECT_TAGS: export
#+EXCLUDE_TAGS:noexport no_export
#+EXCLUDE_TAGS: no_export
#+CREATOR: Emacs 25.2.2 (Org mode 9.1.13)


#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: timestamp:t title:t todo:t |:t
#+OPTIONS: toc:nil



* Abstract
This is the configuration of my EMACS-Editor written in [[https://orgmode.org/][Org mode]] in [[https://en.wikipedia.org/wiki/Literate_programming][literate style programming]]. I've sort of hoarded a lot of different packages and different =.emacs= files from all over the internet and just stucked them together.\\
Using the configuration as is it is is not really advisable. Some things may seem weird and 'wrongly' configured, but hey...this is EMACS.\\
Still, you may found some hidden gems in here that can greatly simplify your work with the editor. I don't use =[[https://github.com/jwiegley/use-package][use-package]]= as I found that it actually makes my emacs sluggish on windows and I actually prefer to have everything in my local config all the time.\\
Download the repo with
#+BEGIN_EXAMPLE
git clone https://github.com/palikar/dotfiles
#+END_EXAMPLE
and setup emacs
#+BEGIN_EXAMPLE
. setup-emacs.sh
#+END_EXAMPLE
//
I've drawn a lot of inspiration for my Emacs configuration form:
- [[https://github.com/zamansky/using-emacs][here]] (for the genera concept of the configuration file)
- [[https://sriramkswamy.github.io/dotemacs/][also here]] (for some of my /hydras/)


* Basic System

** Personal Info
Lets let Emacs know who I am. Probably not a good idea cut them CIA know everything but hey, we trust our "free software", right!

#+BEGIN_SRC emacs-lisp :results none
(setq user-full-name "Stanislav Arnaudov")
#+END_SRC


** Repositories and packages
The default packages repository for emacs is ELPA. ELPA is not super good, we also want MELPA. +MELPA is configured in the .emacs file but here we also add ELPA for good measures+ Everything is here now!
/Edit:/ It's anoying when starting emacs it takes so long to connect to all the sites for the packages and I don't need =package-install= that regularly. With the current setup I fist have to call =setup-packages= in order to install new one but the emacs init time significantly lower. You may or may not care about that time if you run emacs like =emacs --daemon=.
#+BEGIN_SRC emacs-lisp :results none
(require 'package)
(setq package-archives '())

(package-initialize)
(package-refresh-contents)
#+END_SRC
*** Installing packages
I use a lot of additional packages and like to keep them local and installed. I've tried =use-package= but I had some issues and I've opted out for installing everything. The initial waiting when setting up emacs config from scratch is fine by me.
#+BEGIN_SRC emacs-lisp



; all of my packages that I want in my config
; starting-packages
(setq package-list '(ac-R aggressive-indent alect-themes anzu atom-dark-theme auctex auto-complete-clang auto-complete-clang-async auto-complete-nxml auto-org-md base16-theme bash-completion beacon clang-format cmake-font-lock cmake-ide cmake-mode color-theme-modern company-anaconda anaconda-mode company-bibtex company-c-headers company-cmake company-emacs-eclim company-ghci company-irony company-irony-c-headers company-jedi company-quickhelp company-rtags company-web company-ycmd cppcheck cquery crux ctags-update dashboard diminish dired-collapse dired-details dired-du dired-hide-dotfiles dired-icon dired-imenu dired-nav-enhance dired-sidebar dired-subtree dired-hacks-utils doom-themes dot-mode drag-stuff dumb-jump easy-hugo easy-kill eclim ein elpy emlib emmet-mode eslint-fix esxml expand-region eyebrowse fancy-battery fill-column-indicator find-file-in-project firefox-controller fireplace flycheck-clang-analyzer flycheck-clang-tidy flycheck-clangcheck flycheck-irony flycheck-ycmd flyspell-correct-popup flyspell-correct flyspell-popup fontawesome function-args ghub gitignore-templates god-mode golden-ratio google-this google-translate gradle-mode graphql graphviz-dot-mode haskell-mode helm-ag helm-bibtex biblio biblio-core helm-bibtexkey helm-c-yasnippet helm-company helm-flycheck helm-ispell helm-projectile helm-rtags helm-spotify helm-spotify-plus helm helm-core hide-mode-line highlight-indent-guides highlight-indentation highlight-sexp highlight-symbol hugo hungry-delete ibuffer-projectile iedit image-dired+ imenu-list irony-eldoc irony iy-go-to-char java-file-create java-imports java-snippets jedi auto-complete jedi-core epc ctable concurrent json-mode json-reformat json-snatcher keyfreq latex-pretty-symbols latex-preview-pane levenshtein lorem-ipsum lsp-mode dash-functional magit lv git-commit magit-popup markdown-mode maven-test-mode meghanada flycheck company modalka modern-cpp-font-lock moe-theme molokai-theme monokai-theme moz mu4e-alert alert log4e gntp mu4e-conversation multi mustache-mode mvn mvn-help neotree nlinum-relative nlinum noflet org-attach-screenshot org-bullets org-page git mustache org-pdfview org-plus-contrib org2blog htmlize metaweblog ov ox-epub ox-gfm ox-hugo ox-reveal ox-twbs ox-twiki org page-break-lines parsebib pcache pdf-tools pip-requirements plantuml-mode pod-mode popup-complete popup popwin pos-tip powerline-evil evil goto-chg pretty-mode prodigy py-yapf pyenv-mode pymacs python-environment python-pylint python-x folding pythonic pyvenv quickrun ranger rtags skewer-mode js2-mode simple-httpd smart-hungry-delete smart-mode-line-powerline-theme smart-mode-line rich-minority smartparens solarized-theme spaceline-all-the-icons spaceline powerline spacemacs-theme sphinx-doc spinner spotify srefactor sublimity super-save swiper ivy symbol-overlay syntax-subword tabbar tablist telephone-line template transient treemacs-projectile treemacs ht hydra pfuture ace-window projectile treepy try typing typit mmt undo-tree use-package bind-key vimrc-mode virtualenvwrapper visual-regexp-steroids visual-regexp volatile-highlights vue-html-mode web-beautify web-completion-data web-mode websocket wgrep-helm wgrep which-key with-editor async workgroups workgroups2 f anaphora wrap-region wttrin xelb xkcd xml-rpc xterm-color yagist yaml-mode yasnippet-snippets yasnippet ycmd pkg-info epl request-deferred request deferred s dash zeal-at-point zerodark-theme all-the-icons memoize zygospore zzz-to-char avy))
; ending-packages



; activate all the packages (in particular autoloads)
(package-initialize)

; fetch the list of packages available
(unless package-archive-contents
  (package-refresh-contents))

(defun setup-packages ()
  (interactive)
  (setq package-archives '())
  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
  (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)
  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/") t )
  (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/"))
  (package-refresh-contents)
  (setq packages-setup-state t)
  )

(defvar packages-setup-state 'nil)

(dolist (package package-list)
  (unless (package-installed-p package)
    (progn
	  (unless packages-setup-state
		  (setup-packages))
	  (package-install package))))


#+END_SRC


** Key bindings setup
Some major modes overwrite some of my custom keybindings. Therefore I define a custom global minor mode and use the key map of this mode to define my custom key bindings. This sets their precedence 'above' the precedence of the key bindings of other modes
#+BEGIN_SRC emacs-lisp :results none
(define-minor-mode my-keys-mode
  "Minor mode for my personal keybindings."
  :global t
  :keymap (make-sparse-keymap))

(require 'bind-key)
(setf (cdr my-keys-mode-map) nil)


(my-keys-mode t)
#+END_SRC


** Interface tweaks
Making the whole =emacs= experience a tiny bit better with those fixes of the interface of the editor
- Startup screen is anoying
- The toolbar is wasting space
- =f5= should function as a refresh in firefox
- Fringes waste space
- Numbered lines come in handy
- Highlighting the current line is pretty =端bersichtlich=
- Pretty sybols like \lambda over the whole place is pretty cool
- [[https://elpa.gnu.org/packages/nlinum.html][nlinum]] - a mode to display the line numbers but it's much more efficient than the build in /linum/-mode. /nlinum/ can handle big files without a hiccup while scrolling.
#+BEGIN_SRC emacs-lisp :results none
(setq inhibit-startup-message t)
(setq frame-title-format '("Emacs " emacs-version))
(setq cursor-type 'box)
(setq visible-bell 'nil)

(tool-bar-mode -1)
(menu-bar-mode -1)
(fset 'yes-or-no-p 'y-or-n-p)
(fringe-mode '(0 . 0))
(global-nlinum-mode -1)
(global-visual-line-mode 1)
(global-hl-line-mode 1)
(global-prettify-symbols-mode +1)
(scroll-bar-mode 0)
(set-frame-parameter (selected-frame) 'alpha '(85 . 85))
(add-to-list 'default-frame-alist '(alpha . (85 . 85)))
(set-fill-column 80)
(face-spec-set 'secondary-selection '((t (:background "light sky blue" :foreground "black"))))
#+END_SRC

*** Fonts
#+BEGIN_SRC emacs-lisp :results none
;; (set-face-attribute 'default nil :font "SauceCodePro Nerd Font Mono:size=16")

;;(set-frame-font "SauceCodePro Nerd Font Mono:size=15" nil t)
;; (set-default-font "SauceCodePro Nerd Font Mono:size=15")
#+END_SRC


** Behavioral tweaks
Some quick fixes for intuitive and straight forward editing. Generally I strive for the cleanest design the interface possible so I remove a lot from the unnecessary things that come by default with EMACS.
#+BEGIN_SRC emacs-lisp :results none
(setq indent-tabs-mode nil)
(setq auto-save-default nil)
(setq backup-inhibited t)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
(setq mouse-wheel-follow-mouse nil)
(setq scroll-step 1) ;;smooth-ish scrolling
(setq confirm-kill-emacs 'y-or-n-p) ;; Sometimes I fat finger C-x C-c
(setq save-interprogram-paste-before-kill t)
(require 'saveplace) ;; saves your cursor's position in buffers and jumps to it on reopening
(setq save-place t)
(setq save-place-file (locate-user-emacs-file "places" ".emacs-places"))
(setq save-place-forget-unreadable-files nil)
(setq auto-revert-verbose nil) ;; everything is seemless
(setq vc-follow-symlinks t) ;; it asks you everytime otherwise
(delete-selection-mode 1) ;; it's really weird working without that
(load "~/.emacs.d/lisp/syntax-subword")
(global-syntax-subword-mode 1) ;; easy workings with camel case, snake case and pretty much anything else
(global-auto-revert-mode 1) ;; see changes on disc as quick as possible
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
(bind-key* "M-c" 'capitalize-dwim)
(bind-key* "<deletechar>" 'hungry-delete-forward)
(savehist-mode +1)
(setq tab-always-indent 'complete)
(setq require-final-newline t)
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
(setq uniquify-separator "/")
(setq uniquify-after-kill-buffer-p t)    ; rename after killing uniquified
(setq uniquify-ignore-buffers-re "^\\*") ; don't muck with special buffers
(require 'savehist) ;; savehist keeps track of some history
(setq savehist-additional-variables
      '(search-ring regexp-search-ring)
      savehist-autosave-interval 60)
(require 'recentf) ;; save recent files
(add-to-list 'recentf-exclude "\\.windows\\'")
(add-to-list 'recentf-exclude "\\.revive\\'")
(add-to-list 'recentf-exclude "\\/ssh:\\'")
(setq recentf-max-saved-items 500
      recentf-max-menu-items 15
      recentf-auto-cleanup 'never)
(recentf-mode +1)
(require 'super-save)
(add-to-list 'super-save-triggers 'ace-window)
(super-save-mode +1)
(require 'volatile-highlights)
(volatile-highlights-mode t)
(setq mouse-yank-at-point t)
(setq create-lockfiles nil)
(auto-compression-mode t)
#+END_SRC
*** Copy line below
Use =Alt-up/down= as in any other editor to copy lines
#+BEGIN_SRC emacs-lisp :results none
(defun duplicate-line-down()
  (interactive)
  (let ((saved-position (point)))
    (move-beginning-of-line 1)
    (kill-line)
    (yank)
    (open-line 1)
    (next-line 1)
    (yank)
    (goto-char saved-position)
    )
  )
(defun duplicate-line-up()
  (interactive)
  (let ((saved-position (point)))
    (move-beginning-of-line 1)
    (kill-line)
    (yank)
    (move-beginning-of-line 1)
    (open-line 1)
    (yank)
    (goto-char saved-position)
    (next-line 1)
    )
  )

#+END_SRC
*** Making parenthesis smart
Those are pretty much a must when editing code...and also anything else
- Select region and wrap it up with a sybol
  - Cofigured with the standards
  - Cofigured with the formating of =org-mode=
- Insert a opening bracecket and the closing is inserted automagically!
-[[https://github.com/rejeep/wrap-region.el][wrap-region]]
-[[https://github.com/Fuco1/smartparens][smartparens]]
#+BEGIN_SRC emacs-lisp
(require 'wrap-region)
(wrap-region-add-wrapper "=" "=")
(wrap-region-add-wrapper "/" "/")
(wrap-region-add-wrapper "_" "_")
(wrap-region-add-wrapper "+" "+")
(wrap-region-add-wrapper "*" "*")
(wrap-region-add-wrapper "~" "~")
(wrap-region-add-wrapper "$" "$")
(wrap-region-add-wrapper "<" ">")
(wrap-region-add-wrapper ">" "<")

(wrap-region-global-mode t)


(require 'smartparens)
(smartparens-global-mode 1)
#+END_SRC
*** Bytecompiling everything
This function will bytecompile everything that it finds in the .emacs.d directory. This could boots the performance of emacs
#+BEGIN_SRC emacs-lisp

(defun byte-compile-init-dir ()
  "Byte-compile all your dotfiles."
  (interactive)
  (byte-recompile-directory user-emacs-directory 0))

(defun remove-elc-on-save ()
  "If you're saving an elisp file, likely the .elc is no longer valid."
  (add-hook 'after-save-hook
            (lambda ()
              (if (file-exists-p (concat buffer-file-name "c"))
                  (delete-file (concat buffer-file-name "c"))))
            nil
            t))
(add-hook 'emacs-lisp-mode-hook 'remove-elc-on-save)
#+END_SRC
*** Smart moving to the beginning of as line
#+BEGIN_SRC  emacs-lisp :results none
(defun smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

#+END_SRC

- Keybindings
#+BEGIN_SRC emacs-lisp
(bind-key* "C-a" 'smarter-move-beginning-of-line)
#+END_SRC

*** Preventing closing Emacsclient
When you run Emacs as daemon and you connect clients to it, hitting =C-x C-c= will close the client  without asking even though =confirm-kill-emacs= is set to /true/. This snippet will notice if Emacs is ran as daemon and will always ask me to close the current client.
#+BEGIN_SRC emacs-lisp :results none
(when (daemonp)
  (bind-key* "C-x C-c" 'ask-before-closing))
#+END_SRC
*** Scrolling
The default scrolling behavior of Emacs is god awful. This fixes more of the issues.
#+BEGIN_SRC emacs-lisp :results none
(setq scroll-margin 7)
(setq scroll-conservatively 0)
(setq scroll-up-aggressively 0.01)
(setq scroll-down-aggressively 0.01)

(setq-default scroll-up-aggressively 0.01
              scroll-down-aggressively 0.01)

(scroll-all-mode -1)
(setq scroll-conservatively most-positive-fixnum)
(setq scroll-preserve-screen-position t)
#+END_SRC


** Applications
*** GDB
#+BEGIN_SRC emacs-lisp :results none
(setq gdb-many-windows t
      gdb-show-main t)
#+END_SRC
*** Ediff
#+BEGIN_SRC emacs-lisp :results none
(setq ediff-window-setup-function 'ediff-setup-windows-plain
      ediff-split-window-function 'split-window-horizontally)
#+END_SRC
*** Tramp
#+BEGIN_SRC emacs-lisp :results none
;; (tramp-unload-tramp)
;; (require 'tramp)
;; (setq tramp-default-method "ssh"
;;       tramp-backup-directory-alist backup-directory-alist
;;       tramp-ssh-controlmaster-options "ssh")
#+END_SRC
*** Docview
#+BEGIN_SRC emacs-lisp :results none
(setq doc-view-continuous t)
#+END_SRC
*** Dired
#+BEGIN_SRC emacs-lisp :results none
(require 'dired)

(setq dired-dwim-target t)
(setq dired-recursive-copies 'top)
(setq dired-recursive-deletes 'top)
(setq dired-listing-switches "-alh")

(add-hook 'dired-mode-hook 'dired-hide-details-mode)

#+END_SRC
*** Shell
My choice of terminal envinroment in my emacs is /Terminal Emulator/(term). There are two modes to it - /char/ and /line/. Switching between them is made easier with one simple function and some custom key-bindings.
//
 May other IDEs use =F5= for building and compiling projects and I've gotten used to that. Therefore...custom keybinding.
#+BEGIN_SRC emacs-lisp
(require 'term)
(define-key term-mode-map (kbd "C-c C-j") 'my/term-toggle-mode)
(define-key term-mode-map (kbd "C-c C-k") 'my/term-toggle-mode)
(define-key term-raw-map (kbd "C-c C-j") 'my/term-toggle-mode)
(define-key term-raw-map (kbd "C-c C-k") 'my/term-toggle-mode)

(bind-key* "C-<f5>" 'compile)
#+END_SRC


** Function Definitions

#+BEGIN_SRC emacs-lisp :results none

(defun display-startup-echo-area-message ()
  (message "Let the games begin!"))

(defun ask-before-closing ()
  "Close only if y was pressed."
  (interactive)
  (if (y-or-n-p (format "Are you sure you want to close this frame? ")) (save-buffers-kill-emacs)
    (message "Canceled frame close")))

(defun list-installed-packages ()
  "docstring"
  (interactive)
  (describe-variable 'package-activated-list)
  )

(defun transpose-windows (arg) ;; yes, I know, there is also a crux-function that does the exact same thing...still...!!!
  "Transpose the buffers shown in two windows."
  (interactive "p")
  (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
    (while (/= arg 0)
      (let ((this-win (window-buffer))
            (next-win (window-buffer (funcall selector))))
        (set-window-buffer (selected-window) next-win)
        (set-window-buffer (funcall selector) this-win)
        (select-window (funcall selector)))
      (setq arg (if (plusp arg) (1- arg) (1+ arg))))))

(defun find-myinit-file ()
  "Open the myinit.org file which is my actual configuration file."
  (interactive)
  (find-file-other-window "~/.emacs.d/myinit.org"))



(defun comment-or-uncomment-region-or-line ()
  "Comments or uncomments the region or the current line if there's no active region."
  (interactive)
  (save-excursion
    (let (beg end)
      (if (region-active-p)
          (setq beg (region-beginning) end (region-end))
        (setq beg (line-beginning-position) end (line-end-position)))
      (comment-or-uncomment-region beg end))))

(defun my/term-toggle-mode ()
  "Toggles term between line mode and char mode"
  (interactive)
  (if (term-in-line-mode)
      (term-char-mode)
    (term-line-mode)))

(defun fd-switch-dictionary()
  (interactive)
  (let* ((dic ispell-current-dictionary)
    	 (change (if (string= dic "deutsch8") "english" "deutsch8")))
    (ispell-change-dictionary change)
    (message "Dictionary switched from %s to %s" dic change)
    ))

(defun toggle-transparency ()
  (interactive)
  (let ((alpha (frame-parameter nil 'alpha)))
    (set-frame-parameter
     nil 'alpha
     (if (eql (cond ((numberp alpha) alpha)
                    ((numberp (cdr alpha)) (cdr alpha))
                    ((numberp (cadr alpha)) (cadr alpha)))
              100)
         '(85 . 80) '(100 . 100)))))

(defun hot-expand (str)
  "Expand org template."
  (insert str)
  (org-try-structure-completion))


(defun kill-whole-word ()
  (interactive)
  (backward-word)
  (kill-word 1))

(defun kill-whole-line ()
  (interactive)
  (move-beginning-of-line 'nil)
  (kill-line))

(defun replace-or-delete-pair (open)
  "Replace pair at point by OPEN and its corresponding closing character.
The closing character is lookup in the syntax table or asked to
the user if not found."
  (interactive
   (list
    (read-char
     (format "Replacing pair %c%c by (or hit RET to delete pair):"
             (char-after)
             (save-excursion
               (forward-sexp 1)
               (char-before))))))
  (if (memq open '(?\n ?\r))
      (delete-pair)
    (let ((close (cdr (aref (syntax-table) open))))
      (when (not close)
        (setq close
              (read-char
               (format "Don't know how to close character %s (#%d) ; please provide a closing character: "
                       (single-key-description open 'no-angles)
                       open))))
      (replace-pair open close))))

(defun replace-pair (open close)
  "Replace pair at point by respective chars OPEN and CLOSE.
If CLOSE is nil, lookup the syntax table. If that fails, signal
an error."
  (let ((close (or close
                   (cdr-safe (aref (syntax-table) open))
                   (error "No matching closing char for character %s (#%d)"
                          (single-key-description open t)
                          open)))
        (parens-require-spaces))
    (insert-pair 1 open close))
  (delete-pair)
  (backward-char 1))

(defun pass () "A function that does nothing" (interactive))
#+END_SRC


** Customs files

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+END_SRC


** Keybindings

#+BEGIN_SRC emacs-lisp :results none
(bind-key* "C-<f1>" 'toggle-transparency)
(bind-key* "M-<f8>" 'fci-mode)
(bind-key* "<f9>" 'menu-bar-mode)
(bind-key* "C-<f9>" 'hide-mode-line-mode)
(bind-key* "<f10>" 'tool-bar-mode)
(bind-key* "C-<f10>" 'scroll-bar-mode)
(bind-key* "C-<f12>" 'nlinum-mode)

(bind-key* "M-n" 'forward-paragraph)
(bind-key* "M-p" 'backward-paragraph)
(bind-key* "<f5>" 'revert-buffer)

(bind-key* "C-<prior>" 'scroll-down-line)
(bind-key* "C-<next>" 'scroll-up-line)
(bind-key* "C-S-<prior>" 'scroll-down-line)
(bind-key* "C-S-<next>" 'scroll-up-line)
(bind-key* "C-c d" 'delete-file)

(bind-key* "C-S-<down>"  'duplicate-line-down)
(bind-key* "C-S-<up>"  'duplicate-line-up)


(bind-key* "C-+" 'text-scale-increase)
(bind-key* "C--" 'text-scale-decrease)
(bind-key* "C-z" 'zap-up-to-char)
(bind-key* "C-x r e" 'eval-region)
(bind-key* "<f5>" 'revert-buffer)

(bind-key* "M-j <f1>" 'customize-group)
(bind-key* "M-j <f2>" 'setup-packages)
(bind-key* "M-j <f3>" 'package-install)

(bind-key* "C-x k" 'kill-this-buffer)
(bind-key* "C-x K" 'kill-buffer)

(bind-key* "C-c w r" 'replace-or-delete-pair)
(bind-key* "C-c w w" 'kill-whole-word)
(bind-key* "C-c w l" 'kill-whole-line)

(bind-key* "M-<f1>" 'whitespace-cleanup)

(bind-key* "C-<Scroll_Lock>" 'list-installed-packages)

#+END_SRC

Disable some keybindgs cuz' those are just annoying
#+BEGIN_SRC emacs-lisp
(global-unset-key  ( kbd "<prior>"))
(global-unset-key  ( kbd "<next>"))
(global-unset-key  ( kbd "<home>"))
(global-unset-key  ( kbd "<end>"))
(global-unset-key  ( kbd "<insert>"))
(global-unset-key  ( kbd "<insert>"))
(global-unset-key  ( kbd "C-<home>"))
(global-unset-key  ( kbd "C-<end>"))
#+END_SRC


* Windowing
Couple of minor setups that make working with frames a little bit easier. In a lot of cases I just want to switch the position of two windows so there is handy function there. Also, navigating around windows can be a bit weird and slow with just using =C-x o= so =windmove= is set up to work with =C-c= and the arrow keys
** Ace window
For easy navigation between several monitors.
#+BEGIN_SRC emacs-lisp
;; when working with two monitors this is really helpful
(require 'ace-window)
#+END_SRC

** Framer
My little thingy that is kind of useless but I like it. I implemented a mode so that you can resize the windows in Emacs... functionality that already exist.
#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/lisp/arnaud-framer.el")
(require 'arnaud-framer)
(global-framer-mode nil)
#+END_SRC
** Golder Ration
When used, it keeps the focused window the biggest while still having the other ones in a "golder ratioed" size.
#+BEGIN_SRC emacs-lisp
(require 'golden-ratio)
#+END_SRC
** General tweaks
*** Zygospore
Sometimes... I make mistakes. I hit =C-x 1= and bam! I've lost may window config that I actually don't necessarily wanted destroyed. This package fixes this "issue". If I hit =C-x 1= again, I was just where I was before
#+BEGIN_SRC emacs-lisp :results none
(require 'zygospore)
(global-set-key (kbd "C-x 1") 'zygospore-toggle-delete-other-windows)
#+END_SRC
** Keybindgs
#+BEGIN_SRC emacs-lisp
(bind-key* "C-x 4 t" 'transpose-windows)
(bind-key* "C-c <left>"  'windmove-left)
(bind-key* "C-c <right>" 'windmove-right)
(bind-key* "C-c <up>"    'windmove-up)
(bind-key* "C-c <down>"  'windmove-down)

(bind-key* "C-x o" 'ace-window)
#+END_SRC


* Themes
I often alternate between these two and can't really decide which is my favorite one. I depends on the day, I guess. In this case, better to gave them both at one place!
#+BEGIN_SRC emacs-lisp :results none

(setq custom-enabled-themes (quote (spacemacs-dark)))
(setq custom-safe-themes t)


(if (daemonp)
    (add-hook 'after-make-frame-functions
        (lambda (frame)
            (with-selected-frame frame
              (load-theme 'spacemacs-dark t))))
    (load-theme 'spacemacs-dark t))

;; (load-theme 'monokai)
#+END_SRC


* Misc packages
These packages add some minor tweak to EMACS to make text editing easier.
- [[https://github.com/Malabarba/beacon][beacon]] - flashes your cursor after the cursor has been re-positioned.
- [[https://github.com/nflath/hungry-delete]] - deletes all of the white spaces that are 'on the way' after hitting /delete/ or /backspace/. It's weird at first but then you get use to it and kinda crave it and feel its lack if not there.
- [[https://github.com/magnars/expand-region.el][expand-region]] - kinda of a wannabe of that one vim functionality where you select everything between two braces with few simple strokes. This is more powerful but not that precise, to put it mildly. Not that it's not good. Just hit key binding and you can grow the region in both sides by 'semantic increments', whatever that's supposed to mean.
-
#+BEGIN_SRC emacs-lisp
(require 'beacon)
(beacon-mode 1)

(require 'hungry-delete)
(global-hungry-delete-mode)

(require 'expand-region)
(bind-key* "C-c =" 'er/expand-region)
#+END_SRC

** CRUX
...is an abrabiation for /A Collection of Ridiculously Useful eXtensions for Emacs/, so yeah, pretty self-explenatory.
-[[https://github.com/bbatsov/crux][crux]]
#+BEGIN_SRC emacs-lisp :results none
(require 'crux)



(bind-key* "C-c o" 'crux-open-with)
(bind-key* "C-c r" 'crux-rename-file-and-buffer)
(bind-key* "C-c i" 'find-myinit-file)
(bind-key* "C-c I" 'crux-find-user-init-file)
(bind-key* "C-c 1" 'crux-create-scratch-buffer)
(bind-key* "C-c S" 'crux-find-shell-init-file)
(bind-key* "M-k" 'crux-kill-line-backwards)
(bind-key* "C-c t" 'crux-visit-term-buffer)

#+END_SRC

** Q4
Through this packages, I can browse 4chan (only =/g= of course!) threads in my Emacs. It uses the json API of 4chan and renders everything in the editor itself. It even provides some nifty features that are not available in the vanilla 4chan website. I can browser through the replies of a given post, quickly jump to replies of replies and then go back up and also download (through /wget/) images/webms from 4chan directly from here, in my editor. God, I love Emacs.

- [[https://github.com/rosbo018/q4][q4]]

#+BEGIN_SRC emacs-lisp :results none
;; https://boards.4chan.org/r9k/thread/49101515#p49101515 this one !
;; (load-file "/home/arnaud/core.d/code/q4-fork/q4.el")
;; (require 'q4)

;; (bind-key* "M-j q" 'q4/browse-board)
#+END_SRC

** Google This
This is absolutely a genius thing! Mark something, simple key-stroke, BAM!! Google! You are there! You have no idea how much copying and windows switching this package saves. Again, for intuition sake, =C-c g= is the prefix. After that:
- =w= for word
- =s= for selection
- =g= for googling from prompted input
- =SPC= for region
- =l= for line
- =c= for cpp-reference

I also frequanlty use Zeal. It's an application housing tons of usefull documentations and look ups in it while working on somethings are a must. Therefore I have package named *zeal-at-point* that allows me to perform quick search actions in the application with query take form the point. The keybinding for that is =C-c g z= (*Z*eal).
-------------------
- [[https://github.com/Malabarba/emacs-google-this][google-this]]
- [[https://github.com/jinzhu/zeal-at-point][zeal-at-point]]
#+BEGIN_SRC emacs-lisp
(require 'google-this)
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "firefox")
(google-this-mode 1)
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
(bind-key* "C-c g" 'google-this-mode-submap)
(bind-key* "C-c g c" 'google-this-cpp-reference)
(bind-key* "C-c g z " 'zeal-at-point)
#+END_SRC

** PDF-Tools
Viewing pdf files in emacs! Not really indented for big and heavy files but when I have to check on something is does the trick.
- [[https://github.com/politza/pdf-tools][pdf-tools]]
#+BEGIN_SRC emacs-lisp
(require 'pdf-tools)
(require 'org-pdfview)
#+END_SRC


* Programming
Surprisingly I don't have all that much tweaks in here. Commenting out regions or lines is probably the thing I use the most. The other things are just very minor things that are standard in every other IDE.
- [[https://github.com/abo-abo/function-args][function-args]] - package that provies smart completion for function arguments. Works perfectly with *yasnippets*.
#+BEGIN_SRC emacs-lisp
(setq c-default-style '((java-mode . "java") (other . "awk")))
(setq-default c-default-style "awk")
(setq-default indent-tabs-mode nil)
(setq-default c-basic-offset 2)

(add-hook 'proge-mode-hook 'semmantic-highlight-func-mode)
(show-paren-mode 1)

(set-default 'semantic-case-fold t)
(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
(set-default 'semantic-case-fold t)
#+END_SRC

** Keybindgs
#+BEGIN_SRC emacs-lisp :results none
(bind-key* "C-/" 'comment-or-uncomment-region-or-line)
#+END_SRC



** Folding code
A standard IDE feature that comes out of the box with emacs. Just a little tweak to give it nice keybindings. To note is that I use german QWERTZ keyboard so this won't work for all you QWERTY-Normies out there.
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'hs-minor-mode)
(bind-key* "M-端" 'hs-show-all)
(bind-key* "C-M-端" 'hs-hide-all)
(bind-key* "C-端" 'hs-toggle-hiding)
#+END_SRC



** C++
At my work I use this emacs-configuration for a lot of c++ programming. Yet, similar to other sections, the c++ tweaks are...pretty much nothing. Emacs is just that good with no special c++ tweaks.
/Note:/ At some time I plan to experiment with *[[https://github.com/cquery-project/cquery][cquery]]*

#+BEGIN_SRC emacs-lisp :results none
(require 'irony)
(require 'ycmd)
(require 'company-ycmd)
(require 'flycheck-ycmd)
(require 'function-args)
(require 'modern-cpp-font-lock)
(require 'flycheck-clangcheck)
(require 'flycheck-clang-analyzer)

(modern-c++-font-lock-global-mode t)

(fa-config-default)

(set-variable 'ycmd-server-command '("python" "/home/arnaud/code_ext/ycmd/ycmd"))

(set-variable 'ycmd-extra-conf-whitelist '("~/.ycm_extra_conf.py"))
(set-variable 'ycmd-global-config "~/.ycm_extra_conf.py")

(add-hook 'c++-mode-hook 'ycmd-mode)
(add-hook 'c++-mode-hook 'company-ycmd-setup)
(add-hook 'c++-mode-hook 'flycheck-ycmd-setup)
(add-hook 'c++-mode-hook 'function-args-mode)
(add-hook 'c++-mode-hook 'irony-mode)
(add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

(add-hook 'flycheck-mode-hook #'flycheck-irony-setup)
(add-hook 'flycheck-mode-hook #'flycheck-clang-tidy-setup)
(add-hook 'flycheck-mode-hook #'flycheck-clang-analyzer-setup)
(add-hook 'c++-mode-hook #'flycheck-calng-check-setup)

(defun flycheck-calng-check-setup ()
  (setq flycheck-clangcheck-extra-arg "-Wall -std=c++11 -x c++")
  (flycheck-set-checker-executable 'c/c++-clangcheck "/usr/bin/clang-check-7")
  (flycheck-clang-analyzer-setup))

(setq c-default-style "linux")
(setq c-basic-offset 4)
(setq tab-width 4)
(setq indent-tabs-mode t)
(setq c-noise-macro-names '("constexpr"))
;; (c-set-offset 'substatement-open 0)
;; (c-set-offset 'inline-open '0)

(defun vlad-cc-style()
  (c-set-style "linux")
  (c-set-offset 'innamespace '0)
  (c-set-offset 'inextern-lang '0)
  (c-set-offset 'inline-open '0)
  (c-set-offset 'label '*)
  (c-set-offset 'case-label '*)
  (c-set-offset 'access-label '/)
  (setq c-basic-offset 4)
  (setq tab-width 4)
  (setq indent-tabs-mode nil)
)
(add-hook 'c++-mode-hook 'vlad-cc-style)





#+END_SRC

*** Functions

#+BEGIN_SRC emacs-lisp :results none


(defun generate-tags-and-classes ()
  "Documentation."
  (interactive)
  (if (projectile-project-root)
      (progn
        (if (not (file-exists-p (concat (projectile-project-root) "BROWSE")))
            (shell-command-to-string (format "find %s -name '*.cpp' -o -name '*.hpp' | ebrowse -o '%s/BROWSE'" (projectile-project-root) (projectile-project-root))))
        (if (not (file-exists-p (concat (projectile-project-root) "TAGS")))
            (shell-command-to-string (format "find %s -name '*.cpp' -o -name '*.hpp' | xargs etags --append -o '%s/TAGS'" (projectile-project-root) (projectile-project-root)))))
    (progn
      (message "Currently not in project!"))))

;; (add-hook 'c++-mode-hook 'function-args-mode)



#+END_SRC

*** Key-bindings
#+BEGIN_SRC emacs-lisp :results none

(bind-key* "M-j l" 'clang-format)

#+End_SRC

*** Doxymacs

#+BEGIN_SRC emacs-lisp :results none
(load-file "/home/arnaud/.emacs.d/lisp/tempo.el")
(load-file "/home/arnaud/.emacs.d/lisp/xml-parse.el")
(load-file "/home/arnaud/.emacs.d/lisp/doxymacs.el")
(require 'doxymacs)

(setq doxymacs-doxygen-style "JavaDoc")
(setq doxymacs-use-external-xml-parser 't)

(add-hook 'c-mode-common-hook 'doxymacs-mode)

(add-hook 'c-mode-common-hook 'doxymacs-mode)
(defun my-doxymacs-font-lock-hook ()
    (if (or (eq major-mode 'c-mode) (eq major-mode 'c++-mode))
        (doxymacs-font-lock)))
(add-hook 'font-lock-mode-hook 'my-doxymacs-font-lock-hook)

#+END_SRC

**** Keybindings

#+BEGIN_SRC emacs-lisp :results none

(bind-key* "M-j o o" 'doxymacs-insert-function-comment)
(bind-key* "M-j o m" 'doxymacs-insert-member-comment)
(bind-key* "M-j o f" 'doxymacs-insert-file-comment)
(bind-key* "M-j o l" 'doxymacs-insert-blank-singleline-comment)
(bind-key* "M-j o b" 'doxymacs-insert-blank-multiline-comment)
(bind-key* "M-j o c" 'doxymacs-insert-command)

#+END_SRC



** CMake

A minimal Cmake setup, more or less to make my /CMakeLists.txt/ files pleasant to the eyes. I don't really need more as I don't spend that much time writing /cmake/ scripts.
#+BEGIN_SRC emacs-lisp :results none
(require 'cmake-mode)

(autoload 'cmake-font-lock-activate "cmake-font-lock" nil t)
(add-hook 'cmake-mode-hook 'cmake-font-lock-activate)

(setq cmake-tab-width 4)

(setq auto-mode-alist
      (append '(("CMakeLists.txt\\'" . cmake-mode)
                ("\\.cmake\\'" . cmake-mode))
              auto-mode-alist))
#+END_SRC


** Python
I use Python a lot these days. Yet, my python setup in /Emacs/ is less than minimal. I don't know what to say to you. I guess Emacs is that good with python by default.
\\
Myeah, that was a lie from the past. My python setup has evolved since then. I use quite a few packages that transform my Emacs into fully fledged python IDE.
#+BEGIN_SRC emacs-lisp :results none
  (require 'anaconda-mode)
  (require 'py-yapf)
  (require 'pip-requirements)
  (require 'sphinx-doc)
  (require 'elpy)

  (add-to-list 'auto-mode-alist '("\\.py\\'" .  python-mode))
  (add-to-list 'auto-mode-alist '("\\requirements.txt\\'" . pip-requirements-mode))



  (setq elpy-rpc-backend "jedi")
  (setq jedi:setup-keys t)
  (setq jedi:complete-on-dot t)
  (setq jedi:tooltip-method nil)
  (setq jedi:get-in-function-call-delay 0)
  (setq elpy-company-add-completion-from-shell t)

  (setq python-shell-interpreter "python")
  (setq python-shell-interpreter-args "-i")

  ; move quick-help tooltips to the minibuffer
  (setq jedi:tooltip-method nil)

  ; disable all auto-completion unless explicitly invoked with M-tab
  (setq ac-auto-show-menu nil)
  (setq ac-auto-start nil)
  ;; 

#+END_SRC

*** Hooks
#+BEGIN_SRC emacs-lisp

(add-hook 'python-mode-hook 'jedi:setup)
;; (add-hook 'python-mode-hook 'jedi:ac-setup)
;; (add-hook 'python-mode-hook 'elpy-mode)
(add-hook 'python-mode-hook 'sphinx-doc-mode)
(add-hook 'jedi-mode-hook (lambda () (global-auto-complete-mode -1)))

#+END_SRC

*** Keybindings

#+BEGIN_SRC emacs-lisp :results none
(define-key elpy-mode-map [remap elpy-nav-forward-block] nil)
(define-key elpy-mode-map [remap elpy-nav-backward-block] nil)
(define-key elpy-mode-map [remap elpy-nav-backward-indent] nil)
(define-key elpy-mode-map [remap elpy-nav-forward-indent] nil)

(bind-key* "M-j e d" 'sphinx-doc)
(bind-key* "M-j e t" 'elpy-test)
(bind-key* "M-j e f" 'elpy-format-code)
(bind-key* "M-." 'elpy-goto-definition python-mode-map)
;; (bind-key* "M-TAB" 'auto-complete)
#+END_SRC


** Java
I don't really use EMACS for java development as it can be tedious and the packages are not really on part with some other modern IDEs (like Netbeans ;) ). Still, I do have some basic setup for =meghanada= to make my life easier if I have to edit some java program really quick through emacs.
- [[https://github.com/mopemope/meghanada-emacs][meghanada]]
#+BEGIN_SRC emacs-lisp
(require 'meghanada)
(add-hook 'java-mode-hook
          (lambda ()
            (meghanada-mode t)
            (flycheck-mode +1)
            (setq c-basic-offset 2)
            (add-hook 'before-save-hook 'meghanada-code-beautify-before-save)))
(cond
   ((eq system-type 'windows-nt)
    (setq meghanada-java-path (expand-file-name "bin/java.exe" (getenv "JAVA_HOME")))
    (setq meghanada-maven-path "mvn.cmd"))
   (t
    (setq meghanada-java-path "java")
    (setq meghanada-maven-path "mvn")))


#+END_SRC


** Web Mode

From time to time I have to write HTML and other 'web-stuff' and this setup gets me by. It's not really sophisticated and complex but.... come on, it web-programming...no offense. There are a lot Key bindings that come with =web-mode= that I don't really know, mostly because I don't use it that much but if you do, be sure to check them out.
- [[https://github.com/smihica/emmet-mode][emmet-mode]] - =C-j= Expands the emmet code given the minor mode is active
#+BEGIN_SRC emacs-lisp
(require 'web-mode)
(require 'emmet-mode)

(defun my-web-mode-hook ()
  
  (emmet-mode 1)
  
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2)
  (setq web-mode-style-padding 1)
  (setq web-mode-script-padding 1)
  (setq web-mode-block-padding 0)
  (setq web-mode-markup-indent-offset 2)
  
  (setq web-mode-extra-auto-pairs '(("erb"  . (("beg" "end")))
                                    ("php"  . (("beg" "end")
                                               ("beg" "end")))))
  
  (setq web-mode-enable-auto-pairing t)
  (setq web-mode-enable-current-column-highlight t)
  
  (setq web-mode-ac-sources-alist '(("css" . (ac-source-css-property))
                                    ("html" . (ac-source-words-in-buffer ac-source-abbrev)))))

#+END_SRC

*** Auto-mode-alist
#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.api\\'" . web-mode))
(add-to-list 'auto-mode-alist '("/some/react/path/.*\\.js[x]?\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
#+END_SRC
*** Hooks
#+BEGIN_SRC emacs-lisp :results none
(add-hook 'web-mode-hook  'my-web-mode-hook)
#+END_SRC


** Yasnippet
One of the most useful packages that is pretty much a must for a emacs configuration. The package provides a whole bunch of very handy snippets for code/text/structures in almost all major modes of emacs. The default prefix for some of the yas functions is =C-c &= but this really doesn't work for me. Therefore I've defined custom keybindings for the important functions. Also, I write a lot in c++, so I often found myself in the situation where I first expand a ~std::vector~ and then I want to give it a type of ~std::sting~. Stacked snippets are my best friend when it comes to this problem.
- [[https://github.com/joaotavora/yasnippet][yasnippets]]
#+BEGIN_SRC emacs-lisp
(require 'yasnippet)
(require 'yasnippet-snippets)
(require 'helm-c-yasnippet)

(setq yas-snippet-dirs '())

1
(setq yas-snippet-dirs `(
						 ,(concat user-emacs-directory "snippets")
						 ))


(yas-global-mode 1)
(setq helm-yas-space-match-any-greedy t)
(setq yas-triggers-in-field t)
#+END_SRC

*** Keybindgs

#+BEGIN_SRC emacs-lisp :results none
(bind-key* "C-c y n"  'yas/new-snippet)
(bind-key* "C-c y v"  'yas/visit-snippet-file)
(bind-key* "C-c y r"  'yas/reload-all)
(bind-key* "C-<tab>" 'helm-yas-complete)
#+END_SRC


** Fly-check
Syntax error-checking on the fly (haha!) while working on code. It's convenient to avoid small errors that screw up your compilation and are just being anoying.
- [[http://www.flycheck.org/en/latest/][flycheck]]
#+BEGIN_SRC emacs-lisp
(require 'flycheck)
(global-flycheck-mode t)
#+END_SRC


** Aggressive Indent
When writing code I lot of times I mark the things I've just typed and hit /Tab/ to indent it properly. This packages help me not to do that so often as it indents things right before your eyes in the moment you write them. It gets annoying at times but you get used to it pretty quickly.
- [[https://github.com/Malabarba/aggressive-indent-mode][agrssive-indent]]
#+BEGIN_SRC emacs-lisp :results none
(require 'aggressive-indent)
(global-aggressive-indent-mode 1)
(add-to-list 'aggressive-indent-excluded-modes 'html-mode)
(add-to-list
 'aggressive-indent-dont-indent-if
 '(and (derived-mode-p 'c++-mode)
       (null (string-match "\\([;{}]\\|\\b\\(if\\|for\\|while\\)\\b\\)"
                           (thing-at-point 'line)))))

#+END_SRC


** Json

*** Keybindgs

#+BEGIN_SRC emacs-lisp :results none
(bind-key* "M-j j b" 'json-pretty-print-buffer)
(bind-key* "M-j j r" 'json-pretty-print)
#+END_SRC


** Templates


#+BEGIN_SRC emacs-lisp  :results none

(define-skeleton c++-basic-skeleton
  ""
  ""
  "#inlcude <iostream>
#include <string>
#include <vector>
#include <unordered_map>

int main(int argc, char *argv[])
{
	std::cout << \"Starting the program\" << \"\\n\";
    return 0;
}")

(define-skeleton python-basic-skeleton
""
""
"\#!\/usr\/bin\/python
import sys
import os
import json

def main():
    print(\"The program works\")


if __name__ == \'__main__\':
    main()")

(define-skeleton json-basic-skeleton
  ""
  ""
  "{
	\"field_1\": \"value\",
	\"field_2\": {
		\"field_3\": \"value\"
	}
}")

(define-skeleton org-basic-skeleton
""
""
"#+OPTIONS: ':t *:t -:t ::t <:t H:3 \\n:nil ^:t arch:headline author:t
#+OPTIONS: broken-links:nil c:nil creator:nil d:(not \"LOGBOOK\")
#+OPTIONS: date:t e:t email:nil f:t inline:t num:t p:nil pri:nil
#+OPTIONS: prop:nil stat:t tags:t tasks:t tex:t timestamp:t title:t
#+OPTIONS: toc:t todo:t |:t
#+TITLE: Title
#+AUTHOR: Stanislav Arnaudov
#+EMAIL: arnaud@localhost
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 26.1 (Org mode 9.1.13)




\* Title 1

\* Title 2")



(defmacro buffer-from-template (name macro mode)
  ""
  `(let ((new-buff (generate-new-buffer ,name)))
	 (switch-to-buffer  new-buff)
	 (,macro)
	 (,mode)))

#+END_SRC

*** Keybindgs
#+BEGIN_SRC emacs-lisp :results none
(bind-key* "C-c 2" '@(buffer-from-template "*c++*" c++-basic-skeleton c++-mode))
(bind-key* "C-c 3" '@(buffer-from-template "*python*" python-basic-skeleton python-mode))
(bind-key* "C-c 4" '@(buffer-from-template "*json*" json-basic-skeleton json-mode))
(bind-key* "C-c 5" '@(buffer-from-template "*org*" org-basic-skeleton org-mode))
#+END_SRC


** Quickrun

#+BEGIN_SRC emacs-lisp :results none
(require 'quickrun)

(defun my/quickrun-hook ()
  (goto-char (point-min)))
(add-hook 'quickrun-after-run-hook 'my/quickrun-hook)

(quickrun-add-command "c++/warnings"
  '((:command . "g++")
    (:exec    . (
				 "%c -std=c++17 -Wall -Wextra -Wshadow -Wnon-virtual-dtor -pedantic  %o -o %e %s"
				 "%e %a"))
    (:remove  . ("%e"))
	(:description "Compile C++ file with g++ and all of the warnings."))
  :default "c++")

#+END_SRC

*** Keybindgs

#+BEGIN_SRC emacs-lisp :results none
(bind-key* "M-j r h" 'helm-quickrun)
(bind-key* "M-j r r" 'quickrun-with-arg)
(bind-key* "<f7>" 'quickrun)
#+END_SRC


* Text editing
** Alt-moving selection
Another 'standard feature' of most editors but in emacs we have to set it up because this is how we roll. This is just moving the selected block up and down while holding /Alt/
- [[https://github.com/rejeep/drag-stuff.el][drag-stuff]]
#+BEGIN_SRC emacs-lisp
(require 'drag-stuff)
(drag-stuff-global-mode)
(bind-key* "M-<up>" 'drag-stuff-up)
(bind-key* "M-<down>" 'drag-stuff-down)
#+END_SRC


** Vim like killing and yanking
Not exactly what the heading suggests but I've recently learned some vim keybindings and *my god* those get things done fast. Emacs is kind of lacking on this end, but you know what they say
#+BEGIN_QUOTE
Emacs is a nice Operating System but it lacks decent editor
--- Someone big in the Emacs Community
#+END_QUOTE
This package adds some handy functionality to =M-w=. Basically, after the initial command, through key strokes one can select very precisely-ish what is to be put in the kill ring. You can for example hit =M-w= once to "select" the current region but then press =w= again to select the current word. After that you can continue pressing =w= to select one more word.
- [[https://github.com/leoliu/easy-kill][easy-kill]]
#+BEGIN_SRC emacs-lisp
(require 'easy-kill)
(define-key my-keys-mode-map [remap kill-ring-save] 'easy-kill)
#+END_SRC


** Spellchecking
Yeso, I am a +hirroble+ horrible speller. Thank god that there are tools that help me live my miserable uneducated life. I often have to write in german too so I have custom dictionary switching key-binding. Other than that, I find =C-c s= to be most intuitive for correcting misspelled words. *flyspell-popup* is a handy little thing that is pretty much company for showing a list of possible *correct* words. The mode can be swithed on and off with =C-<f8>=
[[https://github.com/xuchunyang/flyspell-popup][flyspell-popup]]
#+BEGIN_SRC emacs-lisp
(require 'flyspell)
(define-key flyspell-mode-map (kbd "C-c s") #'flyspell-popup-correct)
#+END_SRC
*** Keybindgs
#+BEGIN_SRC emacs-lisp
(bind-key* "<f8>"   'fd-switch-dictionary)
(bind-key* "C-<f8>" 'flyspell-mode)
#+END_SRC


** Sexp on steroids
As previously stated, I know tiny bit of vim key-bindings and holy cow those can do a lot of things in very few keystrokes. Emacs is not really like that. I've written some simple functions thal with saving, marking and killing /sexp/s. I really like that feature of vim "*d*elete *i*nside *(*-block" and it kills everything inside the parentesies....or copies it into kill ring or marks it, basically - it's pretty awesome and here I am trying to ripp off exxaclty that.\\
The commands that come in handy a lot of the times and that I've written:

| Keystroke   | Description                                              |
|-------------+----------------------------------------------------------|
|-------------+----------------------------------------------------------|
| =C-M-k=     | Kill erverything inside the current /sexp/               |
| =C-M-K=     | Kill the current /sexp/ and the                          |
| =C-M-SPC=   | Mark erverything inside the current /sexp/               |
| =C-M-S-SPC= | Mar the current /sexp/                                   |
| =C-M-w=     | Save everything inside the current /sexp/ into kill ring |
| =C-M-W=     | Save the current /sexp/ into kill ring                   |


As you've probably noticed =C-M= in like kind of a prefix for all /sexp/-operations

#+BEGIN_SRC emacs-lisp :results none

;; (require 'load-directory)
;; (load-directory "~/.emacs.d/my-lisp")

(load "~/.emacs.d/lisp/arnaud-sexp")
(require 'arnaud-sexp)

(bind-key* "C-M-y" 'sp-backward-up-sexp)
(bind-key* "C-M-x" 'sp-up-sexp)

(bind-key* "C-M-SPC" 'arnaud-mark-sexp)
(bind-key* "C-M-k" 'arnaud-kill-sexp)
(bind-key* "C-M-S-SPC" 'arnaud-mark-sexp-whole)
(bind-key* "C-M-S-k" 'arnaud-kill-sexp-whole)
(bind-key* "C-M-w" 'arnaud-kill-save-sexp)
(bind-key* "C-M-S-w" 'arnaud-kill-save-sexp-whole)
#+END_SRC


* QOL
Extensions/Applications/Packages for Emacs that just plainly do by life easier. The key to getting the job done in an effective manner in having the right tools for it. And you know the Emacs philosophy... "Put _everything_ in your editor!"

** Undo tree
#+BEGIN_SRC emacs-lisp :export src
(require 'undo-tree)
#+END_SRC
*** Keybindgs
#+BEGIN_SRC emacs-lisp
(bind-key* "C-x u" 'undo-tree-visualize)
#+END_SRC


** Projectile
The de-facto standard for project management for emacs. Not sure if I utilize half of its functionality but this file searching and opening...man that feels good when putting it to use. When in a project(which is just a git-repo btw) just type =C-c p f= and be blown away. When you we *helm* with *projectile*, we pretty much get one of the most powerful features in the history of IDEs ever. Some of my relevant keybindings include:
- =f4= - switch to other file. For working with /.cpp/ and /.hpp/ files
- =C-c p f= for finding files the easiest way possible.
- =C-c p d= for finding directories the easiest way possible.
- =M-s= helm-projectile-grep - really cool for searching a phrase of something in a entire project
- =C-c p 4 f= - find file and open it in another window
- =C-c p F= - find file in all known projects
- =C-c p 4 F= find file in all known projects and open it in another window
- =C-c p e= - see recent files
- =C-c p x s= run shell at the root of the project
- =C-c p S= save all files of the current project
----------------------------
Get it here -> [[https://github.com/bbatsov/projectile][PROJECTILE!!!]]
#+BEGIN_SRC emacs-lisp :results none
(require 'projectile)
(setq projectile-completion-system 'helm)
(setq projectile-project-search-path '("/home/arnaud/code" "/home/arnaud/code_ext" "/home/arnaud/code_sys" ))
(setq projectile-indexing-method 'native)
(setq projectile-enable-caching t)

(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)

(projectile-mode)
#+END_SRC


** Neotree
My tree browser of choice. Was blown away when I found that emacs has the ability to pull of something like tree browser. This was probably the functionality that showed me that emacs can be a substitute for every other IDE/text editor(on which the hippsters web-developers write their 'web-apps')
- [[https://github.com/jaypei/emacs-neotree][neotree]]
#+BEGIN_SRC emacs-lisp :results none

;; (load-file "/home/arnaud/core.d/code/all-the-icons.el/all-the-icons.el")
;; (load-file "/home/arnaud/core.d/code/all-the-icons.el/all-the-icons-faces.el")
(load-file "/home/arnaud/code_sys/emacs-neotree-fork/neotree.el")

(require 'neotree)
(require 'all-the-icons)

(add-hook 'neo-after-create-hook
   #'(lambda (_)
	   (with-current-buffer (get-buffer neo-buffer-name)
		 (setq truncate-lines t)
		 (setq word-wrap nil)
		 (make-local-variable 'auto-hscroll-mode)
		 (setq auto-hscroll-mode nil))))



;;(advice-add 'display-graphic-p :override (lambda () t))
;; (setq neo-theme  'icons)


(defun neotree-project-dir ()
	"Open NeoTree using the projectile."
	(interactive)
	(let ((project-dir (projectile-project-root))
		  (file-name (buffer-file-name)))
	  (neotree-toggle)
	  (if project-dir
		  (if (neo-global--window-exists-p)
			  (progn
				(neotree-dir project-dir)
				(neotree-find file-name)))
		(message "Could not find vc project root."))))

(bind-key* "<f1>" 'neotree-toggle)
(bind-key* "C-<f1>" 'neotree-project-dir)

(bind-key* "<f2>" 'neotree-find)


(setq neo-model-line-type 'none)

(setq neo-window-width 40)
(setq neo-window-fixed-size nil)
(setq neo-theme (if (display-graphic-p) 'icons 'arrow))
(setq neo-show-hidden-files t)
;;(setq projectile-switch-project-action 'neotree-projectile-action)
(setq neo-theme 'icons)

(setq neo-hidden-regexp-list (quote ("^\\." "\\.pyc$" "~$" "^#.*#$" "\\.elc$" "\\.o$" "__pycache__")))





(face-spec-set 'neo-button-face '((t (:foreground "gold" :underline nil))))
(face-spec-set 'neo-button-face '((t (:inherit bold :foreground "#268bd2" :underline t :height 1.1 :width semi-condensed))))
(face-spec-set 'neo-file-link-face '((t (:foreground "light sky blue"))))
(face-spec-set 'neo-open-dir-link-face '((t (:foreground "gold" :underline t :height 1.1))))
(face-spec-set 'neo-dir-link-face '((t (:underline t :height 1.1))))
(face-spec-set 'neo-dir-icon-face '((t (:foreground "light sky blue"))))
(face-spec-set 'neo-open-dir-icon-face '((t (:foreground "gold"))))

#+END_SRC


** Helm
The best and the most fully fledged completion engine for emacs IMO. I cannot be productive in my emacs without this. When you are in minibuffer and start typing, things just appear as you type, you can select multiple items, perform actions on all of the (example: open multiple files with single =C-x C-f=) and many more features that I should probably use on more regular basis.
- [[https://github.com/emacs-helm/helm][helm]]
#+BEGIN_SRC emacs-lisp :results none
(require 'helm)
(require 'helm-config)

(setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
      helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
      helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
      helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
      helm-ff-file-name-history-use-recentf t
      helm-echo-input-in-header-line t)

(setq helm-buffers-fuzzy-matching t
      helm-recentf-fuzzy-match t)

(setq helm-semantic-fuzzy-match t
      helm-imenu-fuzzy-match    t)


(setq helm-M-x-fuzzy-match t)

(setq helm-exit-idle-delay 0)
(setq helm-ag-fuzzy-match t)

(setq helm-autoresize-max-height 0)
(setq helm-autoresize-min-height 50)

(helm-mode 1)
;; (helm-autoresize-mode 1)

#+END_SRC
*** Keybindgs
#+BEGIN_SRC emacs-lisp
(bind-key* "C-x C-f" 'helm-find-files)
(bind-key* "M-x" 'helm-M-x)
(bind-key* "C-x b" 'helm-mini)
(bind-key* "C-c b" 'helm-semantic-or-imenu)
(bind-key* "M-s" 'helm-projectile-ag)
(bind-key* "C-x c C-a" 'helm-apt)
(bind-key* "C-x c M-m" 'helm-complete-file-name-at-point)
(bind-key* "C-x c C-s" 'helm-occur-from-isearch)
(bind-key* "C-x r h" 'helm-register)
(bind-key* "M-y" 'helm-show-kill-ring)
#+END_SRC

#+RESULTS:
: helm-show-kill-ring


** IBuffer
This package makes your =C-x C-b= (/list-buffers/) pretty. You can even specify custom sections where the buffers are to be put depending on certain conditions - name, mode, etc. There is also projectile integration but I don't find that very useful. I like the buffers grouped in small more groups.
- [[https://www.emacswiki.org/emacs/IbufferMode][ibuffer]]
#+BEGIN_SRC emacs-lisp :results none
(require 'ibuffer)
(require 'ibuffer-projectile)

(setq ibuffer-expert t)
(setq ibuffer-show-empty-filter-groups nil)


(setq ibuffer-saved-filter-groups
      '(
        ("home"
	 ("Emacs-config" (or (filename . ".emacs")
			     (filename . "myinit.org")))
         ("Org" (or (mode . org-mode)
		    (filename . "OrgMode")))
         ("Programming C++"
          (or
           (mode . c-mode)
           (mode . c++-mode)
           ))
         ("Python"
          (mode . python-mode)
          )
         ("Configurations"
          (or 
           (mode . conf-mode)
           (mode . conf-space-mode)
           (name . ".json")
           (name . ".yaml")
           (name . ".yml")
           ))
         ("Source Code"
          (or
           (mode . emacs-lisp-mode)
           (mode . shell-script-mode)
           (mode . json-mode)
           ))
         ("Dired"
          (mode . dired-mode))
         ("Sripts"
          (name . ".sh")
          )
         ("Documents"
          (mode . doctex-mode)
          )
         ("LaTeX"
          (or
           (mode . tex-mode)
           (mode . latex-mode)
           (name . ".tex")
           (name . ".bib")))
         ("4Chan"
          (mode . q4))
         ("Text" (name . ".txt"))
         ("JS"
          (or (mode . "JavaScript")
              (name . ".js")
              (mode . javascript-mode)))
         ("Web Dev" (or (mode . html-mode)
			(mode . css-mode)
                        (mode . webmode-mode)))
         ("Emacs-created"
          (or
           (name . "^\\*")))
         )))


(define-ibuffer-column size-h
  (:name "Size" :inline t)
  (cond
   ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
   ((> (buffer-size) 100000) (format "%7.0fk" (/ (buffer-size) 1000.0)))
   ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
   (t (format "%8d" (buffer-size)))))


(setq ibuffer-formats
      '((mark modified read-only " "
	      (name 18 18 :left :elide)
	      " "
	      (size-h 9 -1 :right)
	      " "
	      (mode 16 16 :left :elide)
	      " "
	      filename-and-process)))



(add-hook 'ibuffer-mode-hook
	  '(lambda ()
	     (ibuffer-auto-mode 1)
	     (ibuffer-switch-to-saved-filter-groups "home")))

#+END_SRC

*** Get rid of the title and summery
#+BEGIN_SRC emacs-lisp :results none
(defadvice ibuffer-update-title-and-summary (after remove-column-titles)
  (with-current-buffer "*Ibuffer*"
    (read-only-mode 1)
    (goto-char 1)
    (search-forward "-\n" nil t)
    (delete-region 1 (point))
    (let ((window-min-height 1))
      (shrink-window-if-larger-than-buffer))
    (toggle-read-only)))

(ad-activate 'ibuffer-update-title-and-summary)
#+END_SRC

*** Keybindings

#+BEGIN_SRC emacs-lisp :results none
(bind-key* "C-x C-b" 'ibuffer)
#+END_SRC

** Magit


#+BEGIN_SRC emacs-lisp :results none
(require 'magit)
;; Open magit window full-screen
(setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
;; When calling magit-status, save all buffers without further ado
(setq magit-save-repository-buffers 'dontask)
;; Anything longer will be highlighted
(setq git-commit-summary-max-length 70)
(setq magit-commit-show-diff t)

(setq magit-status-sections-hook '(
			;;magit-insert-status-headers
			magit-insert-unstaged-changes
			magit-insert-staged-changes
			magit-insert-untracked-files
			magit-insert-merge-log
			magit-insert-rebase-sequence magit-insert-am-sequence
			magit-insert-sequencer-sequence magit-insert-bisect-output
			magit-insert-bisect-rest magit-insert-bisect-log
			magit-insert-stashes
			magit-insert-unpulled-from-upstream
			magit-insert-unpulled-from-pushremote
			magit-insert-unpushed-to-upstream
			magit-insert-unpushed-to-pushremote))

;; make [MASTER] appear at the end of the summary line
(setq magit-log-show-refname-after-summary t)

(defun my-magit-browse-github ()
    "Browse to the project's github URL, if available"
    (interactive)
    (let ((url (with-temp-buffer
                 (unless (zerop (call-process-shell-command
                                 "git remote -v" nil t))
                   (error "Failed: 'git remote -v'"))
                 (goto-char (point-min))
                 (when (re-search-forward
                        "github\\.com[:/]\\(.+?\\)\\.git" nil t)
                   (format "https://github.com/%s" (match-string 1))))))
      (unless url
        (error "Can't find repository URL"))
      (browse-url url))
	  (with-temp-buffer
		(insert "bind_raise_or_run_web()")
		(call-process-region (point-min) (point-max) "awesome-client" t)))


(setq magit-repository-directories
		'(
		  ("~/code"        . 1)
		  ("~/code_ext/"      . 1))
		magit-repolist-columns
		'(
		  ("Name"    25 magit-repolist-column-ident                  nil)
		  ("Version" 25 magit-repolist-column-version                nil)
		  ("Push"    4 magit-repolist-column-unpushed-to-upstream   (:right-align t))
		  ("Path"    99 magit-repolist-column-path)))

#+END_SRC

*** Keybindgs

#+BEGIN_SRC emacs-lisp :results none
(bind-key* "M-j m g" 'my-magit-browse-github magit-mode-map)
(bind-key* "M-j m l" 'magit-list-repositories)
(bind-key* "M-j m s" 'magit-status)
(bind-key* "M-j m c" 'magit-commit)
(bind-key* "M-j m i" 'magit-init)
(bind-key* "M-j m C" 'magit-checkout-file)
(bind-key* "M-j m M-c" 'magit-checkout)
(bind-key* "M-j m p" 'magit-push)

;; (bind-key "q" 'my--kill-buffer-and-window magit-mode-map)
#+END_SRC
** Hydra
/Hydra/ is a package that allows you to create hydras. Those are like munues with keybindings that popout on the bottom of the buffer and prompt you to type one(or more) of the listed keybindings. This provides really cool way of structuring commands in a menu-like fashion. There are some predifined hydras that come with the package but those are not that good and therefore I've 'borrowed' a few from the mighty internet.
\\
=C-c h= is like the prefix for all my hydras. After that comes another letter (or /C-letter/) that selects the desired hydra.

| Keybinding       | Hydra              |
|------------------+--------------------|
|------------------+--------------------|
| =<prefix> b=     | Bookmarks          |
| =<prefix> r=     | Rectangle          |
| =<prefix> R=     | Registers          |
| =<prefix> C-o m= | Org Tress movement |
| =<prefix> C-o t= | Org Templates      |
| =<prefix> f=     | Formating          |
| =<prefix> p=     | Projectile         |
| =<prefix> M=     | Modes              |
| =<prefix> m=     | Magit              |
| =<prefix> F=     | Files              |



There is also a 'special' Hydra that lists all other hydras and it's bound to =C-c h h=
-------------------
 - [[https://github.com/abo-abo/hydra][hydra]]

#+BEGIN_SRC emacs-lisp :results none
(require 'hydra)
(require 'hydra-examples)
#+END_SRC

*** Windowing

#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-windowing (:color blue
                               :hint nil)
  "
 ^Ace-window^                        ^^
^^^^------------------------------------------------------------------
^ _s_: Select window^           ^ _o_: Ace^
^ _d_: Delete window^
^ _m_: Maximize window^
^ _c_: Close other windows^
^ _t_: Transpose windows^

"
  ("s" ace-select-window)
  ("d" ace-delete-window)
  ("m" ace-maximize-window)
  ("c" ace-delete-other-windows)
  ("t" ace-swap-windows)
  ("o" ace-window)
  ("q" nil :color blue))

(bind-key* "C-c h w" 'arnaud-hydra-windowing/body)
#+END_SRC
*** Bookmarks navigation
#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-bookmarks (:color blue
                              :hint nil)
  "
 _s_: set  _b_: bookmark   _j_: jump   _d_: delete   _q_: quit
  "
  ("s" bookmark-set)
  ("b" bookmark-save)
  ("j" bookmark-jump)
  ("d" bookmark-delete)
  ("q" nil :color blue))
(bind-key* "C-c h b" 'arnaud-hydra-bookmarks/body)
#+END_SRC

*** Editing rectangle
#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-rectangle (:pre (rectangle-mark-mode 1)
                                   :color blue
                                   :hint nil)
  "
 _p_: paste   _r_: replace  _I_: insert
 _y_: copy    _o_: open     _V_: reset
 _d_: kill    _n_: number   _q_: quit
"
  ("h" backward-char nil)
  ("l" forward-char nil)
  ("k" previous-line nil)
  ("j" next-line nil)
  ("y" copy-rectangle-as-kill)
  ("d" kill-rectangle)
  ("x" clear-rectangle)
  ("o" open-rectangle)
  ("p" yank-rectangle)
  ("r" string-rectangle)
  ("n" rectangle-number-lines)
  ("I" string-insert-rectangle)
  ("V" (if (region-active-p)
           (deactivate-mark)
         (rectangle-mark-mode 1)) nil)
  ("q" keyboard-quit :color blue))

(bind-key* "C-c h r" 'arnaud-hydra-rectangle/body)
#+END_SRC
*** Registers
#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-registers (:color blue
                              :hint nil)
  "
 _a_: append     _c_: copy-to    _j_: jump            _r_: rectangle-copy   _q_: quit
 _i_: insert     _n_: number-to  _f_: frameset        _w_: window-config
 _+_: increment  _p_: point-to   _h_: helm-register
  "
  ("a" append-to-register)
  ("c" copy-to-register)
  ("i" insert-register)
  ("f" frameset-to-register)
  ("j" jump-to-register)
  ("n" number-to-register)
  ("r" copy-rectangle-to-register)
  ("w" window-configuration-to-register)
  ("+" increment-register)
  ("p" point-to-register)
  ("h" helm-register)
  ("q" nil :color blue))
(bind-key* "C-c h R" 'arnaud-hydra-registers/body)
#+END_SRC
*** Modes toggling
#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-active-modes (:color red
                                       :hint nil)
  "
 _b_: fancy battery   _C-c_: flycheck       _c_: company     _j_: jedi
 _l_: linenum         _v_: visual-line      _h_: hs-minor    _g_: golden-ratio
 _f_: flyspell        _y_: yas              _e_: emmet       _f_: framer
 _q_: quit
"
  ("b" fancy-battery-mode)
  ("l" global-nlinum-mode)
  ("f" flyspell-mode)
  ("C-c" global-flycheck-mode)
  ("v" visual-line-mode)
  ("y" yas-global-mode)
  ("c" company-mode)
  ("h" hs-minor-mode)
  ("e" emmet-mode)
  ("j" jedi-mode)
  ("g" golden-ratio-mode)
  ("f" global-framer-mode)
  ("q" nil :color blue))


(bind-key* "C-c h M" 'arnaud-hydra-active-modes/body)
#+END_SRC
*** Org trees movement
#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-org-organize (:color red
                                            :hint nil)
  "
       ^Meta^
^^--------------------------------------------------------------------
      ^ _<up>_ ^          _q_: quit
 _<right>_ ^+^ _<left>_
      ^_<down>_^
"
  ("<left>" org-metaleft)
  ("<right>" org-metaright)
  ("<down>" org-metadown)
  ("<up>" org-metaup)
  ("q" nil :color blue))

(bind-key* "C-c h C-o m" 'arnaud-hydra-org-organize/body)
#+END_SRC
*** Org templates expansions
#+BEGIN_SRC emacs-lisp :results none


(defhydra arnaud-hydra-org-template (:color blue
                                 :hint nil)
  "
 ^One liners^                                        ^Blocks^                                      ^Properties^
--------------------------------------------------------------------------------------------------------------------------------------------------------
 _a_: author        _i_: interleave  _D_: description    _C_: center      _p_: python src    _n_: notes    _d_: defaults   _r_: properties        _<_: insert '<'
 _A_: date          _l_: label       _S_: subtitle       _e_: elisp src   _Q_: quote                     _L_: latex      _I_: interleave        _q_: quit
 _c_: caption       _N_: name        _k_: keywords       _E_: example     _s_: src                       _x_: export     _T_: drill two-sided
 _f_: file tags     _o_: options     _M_: minted         _h_: html        _v_: verbatim                  _X_: noexport
 _H_: latex header  _t_: title       _P_: publish        _m_: matlab src  _V_: verse
 "
  ("a" (hot-expand "<a"))
  ("A" (hot-expand "<A"))
  ("c" (hot-expand "<c"))
  ("f" (hot-expand "<f"))
  ("H" (hot-expand "<H"))
  ("i" (hot-expand "<i"))
  ("I" (hot-expand "<I"))
  ("l" (hot-expand "<l"))
  ("n" (hot-expand "<n"))
  ("N" (hot-expand "<N"))
  ("P" (hot-expand "<P"))
  ("o" (hot-expand "<o"))
  ("t" (hot-expand "<t"))
  ("C" (hot-expand "<C"))
  ("D" (hot-expand "<D"))
  ("e" (hot-expand "<e"))
  ("E" (hot-expand "<E"))
  ("h" (hot-expand "<h"))
  ("k" (hot-expand "<k"))
  ("M" (hot-expand "<M"))
  ("m" (hot-expand "<m"))
  ("p" (hot-expand "<p"))
  ("Q" (hot-expand "<q"))
  ("s" (hot-expand "<s"))
  ("S" (hot-expand "<S"))
  ("v" (hot-expand "<v"))
  ("V" (hot-expand "<V"))
  ("x" (hot-expand "<x"))
  ("X" (hot-expand "<X"))
  ("d" (hot-expand "<d"))
  ("L" (hot-expand "<L"))
  ("r" (hot-expand "<r"))
  ("I" (hot-expand "<I"))
  ("T" (hot-expand "<T"))
  ("b" (hot-expand "<b"))
  ("<" self-insert-command)
  ("q" nil :color blue))

(bind-key* "C-c h C-o t" 'arnaud-hydra-org-template/body)
#+END_SRC
*** Formatting
#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-format (:color blue
                               :hint nil)
  "
 ^Beautify^
^^^^^^^^^^--------------------------------------
 _h_: html        _c_: css       _j_: js        _q_: quit
 _H_: html buf    _C_: css buf   _J_: js buf
 _p_: py buf      _P_: py on-sav
"
  ("h" web-beautify-html)
  ("H" web-beautify-html-buffer)
  ("c" web-beautify-css)
  ("C" web-beautify-css-buffer)
  ("j" web-beautify-js)
  ("J" web-beautify-js-buffer)
  ("p" py-yapf-buffer)
  ("P" py-yapf-enable-on-save)
  ("q" nil :color blue))
(bind-key* "C-c h f" 'arnaud-hydra-format/body)
#+END_SRC
*** Projectile
#+BEGIN_SRC emacs-lisp :results none
(defhydra hydra-projectile-other-window (:color teal)
  "projectile-other-window"
  ("f"  projectile-find-file-other-window        "file")
  ("g"  projectile-find-file-dwim-other-window   "file dwim")
  ("d"  projectile-find-dir-other-window         "dir")
  ("b"  projectile-switch-to-buffer-other-window "buffer")
  ("q"  nil                                      "cancel" :color blue))

(defhydra arnaud-hydra-projectile (:color teal :hint nil)
  "
     PROJECTILE: %(projectile-project-root)

     Find File            Search/Tags          Buffers                Cache
------------------------------------------------------------------------------------------
_s-f_: file            _a_: ag                _i_: Ibuffer           _c_: cache clear
 _ff_: file dwim       _g_: update gtags      _b_: switch to buffer  _x_: remove known project
 _fd_: file curr dir   _o_: multi-occur     _s-k_: Kill all buffers  _X_: cleanup non-existing
  _r_: recent file                                               ^^^^_z_: cache current
  _d_: dir

"
  ("<ESC>" nil "quit")
  ("<" hydra-project/body "back")
  ("a"   projectile-ag)
  ("b"   projectile-switch-to-buffer)
  ("c"   projectile-invalidate-cache)
  ("d"   projectile-find-dir)
  ("s-f" projectile-find-file)
  ("ff"  projectile-find-file-dwim)
  ("fd"  projectile-find-file-in-directory)
  ("g"   ggtags-update-tags)
  ("s-g" ggtags-update-tags)
  ("i"   projectile-ibuffer)
  ("K"   projectile-kill-buffers)
  ("s-k" projectile-kill-buffers)
  ("m"   projectile-multi-occur)
  ("o"   projectile-multi-occur)
  ("s-p" projectile-switch-project "switch project")
  ("p"   projectile-switch-project)
  ("s"   projectile-switch-project)
  ("r"   projectile-recentf)
  ("x"   projectile-remove-known-project)
  ("X"   projectile-cleanup-known-projects)
  ("z"   projectile-cache-current-file)
  ("`"   hydra-projectile-other-window/body "other window" :color blue)
  ("q"   nil "cancel" :color blue))

(bind-key* "C-c h p" 'arnaud-hydra-projectile/body)
#+END_SRC
*** Magit

#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-magit (:color blue :hint nil)
  "
      Magit: %(magit-get \"remote\" \"origin\" \"url\")

 ^Status^      ^Remote^          ^Operations^
^^^^^^------------------------------------------------------------------------------------------
_s_: Status      _f_: Pull       _c_  : Commit
_l_: Log all     _p_: Push       _C-s_: Stage
_d_: Diff        _C-c_: Clone    _S_  : Stage modified
 ^^                 ^^           ^_C-f_: Stage file^
 ^^                 ^^           ^_M-f_: Unstage file^
"
  ("f" magit-pull)
  ("p" magit-push)
  ("c" magit-commit)
  ("C-c" magit-clone)
  ("d" magit-diff)
  ("l" magit-log-all )
  ("s" magit-status)
  ("C-s" magit-stage)
  ("C-f" magit-stage-file)
  ("M-f" magit-unstage-file)
  ("S" magit-stage-modified)
  ("q" nil "Cancel" :color blue))



(bind-key* "C-c h m" 'arnaud-hydra-magit/body)
#+END_SRC
*** Files

#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-files (:color teal :hint nil)
"
    ^^                    ^Files^             ^^
^^^^^^------------------------------------------------------------------------
^_n_^ : Notes
^_t_^ : Todos
^_a_^ : About(Blog)
^_i_^ : Myinit
"

  ("n" (find-file "~/Dropbox/orgfiles/notes.org") )
  ("t" (find-file "~/Dropbox/orgfiles/todos/todos.org"))
  ("a" (find-file "~/code/palikar.github.io/org/about.org"))
  ("i" (find-file "~/code/dotfiles/.emacs.d/myinit.org"))
  ("q" nil "Cancel" :color blue))

(bind-key* "C-c h F" 'arnaud-hydra-files/body)
#+END_SRC

*** Hydras
#+BEGIN_SRC emacs-lisp :results none
(defhydra arnaud-hydra-hydras (:color teal :hint nil)
"
    ^^                    ^Available Hydras^             ^^
^^^^^^------------------------------------------------------------------------
^_w_^ : Windowing    ^_R_^     : Registers            ^_f_^ : Formating
^_b_^ : Bookmarks    ^_M_ ^    : Modes                ^_p_^ : Projectile
^_r_^ : Rectangle    ^_C-o m_^ : Org treee move       ^_m_^ : Magit
^_l_^ : LaTeX        ^_C-o t_^ : Org templates        ^_F_^ : Files

"
  ("w" arnaud-hydra-windowing/body)
  ("b" arnaud-hydra-bookmarks/body)
  ("r" arnaud-hydra-rectangle/body)
  ("R" arnaud-hydra-registers/body)
  ("M" arnaud-hydra-modes/body)
  ("C-o m" arnaud-hydra-org-organize/body)
  ("C-o t" arnaud-hydra-org-template/body)
  ("f" arnaud-hydra-formating/body)
  ("p" arnaud-hydra-projectile/body)
  ("m" arnaud-hydra-magit/body)
  ("l" arnaud-hydra-latex/body)
  ("F" arnaud-hydra-files/body)
  ("q" nil "Cancel" :color blue))

(bind-key* "C-c h h" 'arnaud-hydra-hydras/body)
#+END_SRC


** IMenu
IMenu is like that one thingy that nobody uses but its in almost every IDE. IMenu can create a buffer showing the "structure" of what you are currently editing. If you are writing a C++ class, it will show you all the member functions and fields. If you are working on \Latex document, the  IMenu buffer will contain the sections and the subsections. The whole thing is occasionally useful but certainly does not need to clutter your workspace the whole time.

- https://github.com/bmag/imenu-list
#+BEGIN_SRC emacs-lisp :results none
(require 'imenu-list)

(setq imenu-list-auto-resize t)
(setq imenu-list-after-jump-hook nil)
#+END_SRC

*** Keybindings

#+BEGIN_SRC emacs-lisp :results none
(bind-key* "<f12>" 'imenu-list-smart-toggle)
#+END_SRC


** Company
Complete Anything! I am yet to find an effective setup that is as fast as well as feature rich. I've defined hooks for some of the major modes that I use so that I don't hold too many active backends at the start. A lot of times I found myself turning off company-mode because it just makes the typing slower at some moments. The ~company-idle-delay~ makes the automatic popup +impossible+ immediate so that I +would+ wouldn't have to call it manually through =M-m=.
- [[http://company-mode.github.io/][company]]

*** Basic setup
#+BEGIN_SRC emacs-lisp :results none
(global-auto-complete-mode 'nil)

(setq company-minimum-prefix-length 3
	  company-tooltip-align-annotations nil
	  company-tooltip-flip-when-above nil
	  company-idle-delay 'nil
	  company-show-numbers nil
	  company-echo-truncate-lines nil
	  company-tooltip-maximum-width 100
	  company-tooltip-minimum-width 100)
(global-company-mode t)

(bind-key* "M-m" 'company-complete)
(define-key company-active-map (kbd "C-n") 'company-select-next-or-abort)
(define-key company-active-map (kbd "C-p") 'company-select-previous-or-abort)

(setq company-backends '())
(setq company-frontends '(company-pseudo-tooltip-unless-just-one-frontend))
(setq company-tooltip-maximum-width 100)
(setq company-tooltip-minimum-width 100)


(face-spec-set 'company-preview '((t (:background "#444444" :foreground "light sky blue"))))
(face-spec-set 'company-tooltip '((t (:background "#444444" :foreground "light sky blue"))))
(face-spec-set 'company-tooltip-annotation '((t (:foreground "deep sky blue"))))


(require 'company-meghanada)
(require 'company)
(require 'company-cmake)
(require 'company-jedi)
(require 'company-meghanada)
(require 'company-irony)
(require 'company-nxml)
(require 'company-anaconda)
#+END_SRC

\\
In my experience, setting up the backends of company properly is not the easiest thing. I've tried a lot of things and  I've finally come up with this approach. I've defined a function that sets up the right backends for each task of mine. The functions are first bound to hooks so that the whole thing is kinda automatic. This, however, does not seem to work in one hundred percent of the cases. Therefore, I also can call the functions through some keybindings and/or hydra.
*** Function definitions
The definitions of all the functions for the backends setups.
- basic packages variable - I  use the backends in this variable across all modes
#+BEGIN_SRC emacs-lisp :results none
(defvar basic-company-backends '(company-files
                                 company-capf
                                 company-dabbrev-code
                                 company-keywords
                                 company-dabbrev))
#+END_SRC
- functions
#+BEGIN_SRC emacs-lisp :results none
(defun my-company-basic-backends (args)
  (interactive)
  (setq company-backends `(,basic-company-backends)))

(defun  my-company-nxml-backends ()
  (interactive)
  (message "Basic backends engaged.")
  (setq company-backends `(company-capf
                           ,basic-company-backends)))

(defun  my-company-nxml-backends ()
  (interactive)
  (message "xXML backends engaged.")
  (setq company-backends `(company-capf
                           ,basic-company-backends)))

(defun my-company-java-backends ()
  (interactive)
  (message "Java backends engaged.")
  (setq company-backends `(company-meghanada
                           ,basic-company-backends)))



(defun my-company-c++-backends ()
  (interactive)
  (message "C++ backends engaged.")
  (setq company-backends `(
						   company-irony
						   company-ycmd
						   company-c-headers
						   company-irony-c-headers
						   ,basic-company-backends)))


(defun my-company-cmake-backends ()
  (interactive)
  (message "CMake backends engaged.")
  (setq company-backends `(company-cmake
                           ,basic-company-backends)))



(defun my-company-python-backends ()
  (interactive)
  (message "Python backends engaged.")
  (setq company-backends `(company-jedi
						   elpy-company-backend
                           ,basic-company-backends)))


(defun my-company-latex-backends ()
  (interactive)
  (message "Latex backends engaged.")
  (setq company-backends `( (company-auctex-bibs
                             company-auctex-macros
                             company-auctex-labels
                             company-auctex-symbols
                             company-auctex-environments)
                            ,basic-company-backends)))

(defun my-company-elisp-backends ()
  (interactive)
  (message "ELisp backends engaged.")
  (setq company-backends `(company-capf
                           ,basic-company-backends)))

#+END_SRC
*** Hooks
Automation...60% of the time it works every time!
#+BEGIN_SRC emacs-lisp :results none
(add-hook 'python-mode-hook 'my-company-python-backends)
(add-hook 'nxml-mode-hook 'my-company-nxml-backends)
(add-hook 'meghanada-mode-hook 'my-company-java-backends)
(add-hook 'latex-mode-hook 'my-company-latex-backends)
(add-hook 'cmake-mode-hook 'my-company-cmake-backends)
(add-hook 'c++-mode-hook 'my-company-c++-backends)
(add-hook 'emacs-lisp-mode-hook 'my-company-elisp-backends)
#+END_SRC
*** Hydra
Hooks are nice but sometimes I want some finer control of which backends are activated in company.
#+BEGIN_SRC emacs-lisp :results none

(defhydra arnaud-hydra-company (:color red
                                       :hint nil)
  "
                       Company backends
----------------------------------------------------------

 _p_: Python   _l_: Latex     _e_: ELisp
 _x_: nXML     _m_: CMake
 _j_: Java     _c_: C++

_b_: Basic

 _q_: quit

"
  ("p" my-company-python-backends)
  ("x" my-company-nxml-backends  )
  ("j" my-company-java-backends  )
  ("l" my-company-latex-backends )
  ("m" my-company-cmake-backends )
  ("c" my-company-c++-backends   )
  ("e" my-company-elisp-backends )
  ("b" my-company-basic-backends )
  ("q" nil :color blue))
#+END_SRC
*** Faces
#+BEGIN_SRC emacs-lisp :results none

(face-spec-set 'company-preview '((t (:background "#444444" :foreground "light sky blue"))))
(face-spec-set 'company-tooltip '((t (:background "#444444" :foreground "light sky blue"))))
(face-spec-set 'company-tooltip-annotation '((t (:foreground "deep sky blue"))))

#+END_SRC

*** Keybindgs
Hydras are nice but sometimes I just want hit some keys and have what I want
- Quick keybinds to swtich backends
#+BEGIN_SRC emacs-lisp :results none
(bind-key* "M-j c p" 'my-company-python-backends)
(bind-key* "M-j c x" 'my-company-nxml-backends  )
(bind-key* "M-j c j" 'my-company-java-backends  )
(bind-key* "M-j c l" 'my-company-latex-backends )
(bind-key* "M-j c m" 'my-company-cmake-backends )
(bind-key* "M-j c c" 'my-company-c++-backends   )
(bind-key* "M-j c e" 'my-company-elisp-backends )
(bind-key* "M-j c b" 'my-company-basic-backends )
#+END_SRC
- The Hydry-thingy
#+BEGIN_SRC emacs-lisp :results none
(bind-key* "C-c h c" 'arnaud-hydra-company/body)
#+END_SRC


** Avy
Navigate by searching for a letter on the screen and jumping to it. Useful for quick navigation and getting to places on the screen.
- [[https://github.com/abo-abo/avy][avy]]
#+BEGIN_SRC emacs-lisp
(require 'avy)
#+END_SRC
*** Keybindgs
#+BEGIN_SRC emacs-lisp
(bind-key* "<f13>" 'avy-goto-word-1)
(bind-key* "C-<f13>" 'avy-goto-char)

#+END_SRC


** Iy
Go to next CHAR which is similar to "f" and " t" in /vim/. To note is that I don't think that this package will remember the state of your mark when you make the jump. So if you have the expression =int funcName(int a, int b)=, the cursor is at the beginning of the expression and you type =C-SPC C-c f (= you won't mark everything till the =(= (now I believer this sentence to be lie). Still useful though.
- [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]]
#+BEGIN_SRC emacs-lisp
(require 'iy-go-to-char)
#+END_SRC
*** Keybindgs
#+BEGIN_SRC emacs-lisp
(bind-key* "C-c f" 'iy-go-up-to-char)
(bind-key* "C-c F" 'iy-go-up-to-char-backward)
#+END_SRC


** Swiper and Anzu
=Isearch= is great but I have ever wanted a isearch on steroids...or something with helm infused isearch. =Swiper= is exaclty that. =Anzu= is a mode line tweak that displays the number of found things by isearch but not by swiper. Yes, I should probably fix that some time in the future.
- [[https://github.com/abo-abo/swiper][Swiper]]
- [[https://github.com/syohex/emacs-anzu][Anzu]]
\\
/Note:/ I do also sometimes use /helm-occur-from-isearch/ in order to find something. I still like to have different possibilities while performing an action and picking the best one in each individual case.
\\
/Update/: I've switched back to *isearch* for now
#+BEGIN_SRC emacs-lisp
(require 'swiper)
(require 'ivy)
(require 'anzu)

(setq ivy-display-style (quote fancy))
(setq search-whitespace-regexp ".*?")

(global-anzu-mode +1)
#+END_SRC
*** Keybindgs
#+BEGIN_SRC emacs-lisp
(bind-key* "C-c M-s"  'swiper)
(bind-key* "C-s"  'isearch-forward)
(bind-key* "M-%" 'anzu-query-replace)
(bind-key* "C-M-%" 'anzu-query-replace-regexp)
#+END_SRC


** IEdit and Visual Regexp
*** COMMENT IEdit
IEdit is kinda like real time search and replace. It's similar to that one vim feature that I see people using from time to time. After a word is selected by the region, you can go into iedit-mode with ~M-i~ and while editing the marked region, all other occurrences will be changed accordingly.
- [[https://github.com/victorhge/iedit][iedit]]
#+BEGIN_SRC emacs-lisp :results none
(require 'iedit)
(face-spec-set 'iedit-occurrence '((t (:background "pale green" :foreground "black"))))
#+END_SRC

*** Visual Regexp
#+BEGIN_SRC emacs-lisp
(require 'visual-regexp)
(require 'visual-regexp-steroids)
#+END_SRC

*** Keybindings
#+BEGIN_SRC emacs-lisp :results none
;; (bind-key* "M-%" 'vr/select-query-replace)
(bind-key* "M-%" 'query-replace)

(bind-key* "M-i"   'iedit-mode)
(bind-key* "C-M-i" 'iedit-mode-toggle-on-function)

#+END_SRC


** Yagist

#+BEGIN_SRC emacs-lisp :results none
(require 'yagist)

(bind-key* "M-j g l" 'yagist-list)
(bind-key* "M-j g r" 'yagist-region)
(bind-key* "M-j g b" 'yagist-buffer)
#+END_SRC


** Sunrise Commander

#+BEGIN_SRC emacs-lisp
;; (load "~/.emacs.d/lisp/sunrise-commander.el")
;; (require 'sunrise-commander)
;; (require 'sunrise-x-buttons)
;; (require 'sunrise-x-modeline)

#+END_SRC



** Gitignore templates

#+BEGIN_SRC emacs-lisp
(require 'gitignore-templates)
#+END_SRC

*** Keybindgs
#+BEGIN_SRC emacs-lisp
(bind-key* "M-j i i" 'gitignore-templates-insert)
(bind-key* "M-j i f" 'gitignore-templates-new-file)
#+END_SRC


** Prodigy

#+BEGIN_SRC emacs-lisp :results none
(require 'prodigy)


(prodigy-define-service
  :name "Python Server"
  :command "python"
  :args '("-m" "http.server" "6001")
  :cwd "/home/arnaud/core.d/www"
  :tags '(server)
  :stop-signal 'sigkill
  :kill-process-buffer-on-stop t)

(prodigy-define-service
  :name "Hugo Local Blog"
  :command "hugo"
  :args '("server" "-D" )
  :cwd "/home/arnaud/code/blog-hugo-files"
  :tags '(server)
  :stop-signal 'sigkill
  :kill-process-buffer-on-stop t)



#+END_SRC

*** Keybindgs

#+BEGIN_SRC emacs-lisp :results none
(bind-key* "M-j p" 'prodigy)
#+END_SRC


* Markup

** Markdown
Markdown is not as pretty as Org-mode but is widely used throughout the Internet. I often have to open /.md/ files and therefore it's worth making them look pretty in my emacs. The =markdown-mode= provies exaclty that.
-[[https://jblevins.org/projects/markdown-mode/][markdown-mode]]
#+BEGIN_SRC emacs-lisp
(autoload 'markdown-mode "markdown-mode"
   "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.text\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.txt\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode))
#+END_SRC

** Org-mode
*** Common settings
Org-mode is awesome not just for note taking but also for general text editing, formating and all and all just plain old /writing/. Therefore some basic org-mode configuration comes at handy when working with =.org= files (this /init/ file is written in org-mode so...yeah!!). The =org-bullets= makes the heading look pretty. I have couple of extra exporters for =.org= files that just make my life easier.

#+BEGIN_SRC emacs-lisp
(require 'org-bullets)
(require 'org-tempo)

(setq org-support-shift-select (quote always))
(setq org-startup-indented t)
(setq org-hide-leading-stars t)
(setq org-babel-python-command "python")
(setq org-directory "~/Documents/orgfiles")
(setq org-default-notes-file (concat org-directory "/notes.org"))
(setq org-export-html-postamble nil)
(setq org-startup-folded (quote overview))
(setq org-log-done 'time)

(setq org-pretty-entities t)
(setq org-export-babel-evaluate nil)
(setq org-export-with-smart-quotes t)
(setq org-enable-priority-commands nil)
(setq org-html-htmlize-output-type 'css)

(setq org-latex-listings 'minted
      org-latex-packages-alist '(("" "minted"))
      org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

(setq org-highlight-latex-and-related '(latex script entities))


(add-hook 'org-mode-hook (lambda ()
                           (org-bullets-mode 1)
                           (flyspell-mode 1)))
#+END_SRC
The codeblocks should be formated with the native envinroment of the language
#+BEGIN_SRC emacs-lisp :results none

(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-confirm-babel-evaluate nil)
(setq org-edit-src-content-indentation 0)

#+END_SRC
*** Exporters
Some extra export backends for org-mode that come in handy.
- Beamer - for making those awesome-ish presentations
- twbs(Tweeter Bootstrap) - quickly make your org files look really pretty
- hugo - I use Hugo for blogging and the exporter allows me to write every single content page in /org-mode/
- gfm (Github Flavored Markdown) - this makes writing /README.md/ files easy (i.e. writing them in org-mode)
#+BEGIN_SRC emacs-lisp
(require 'ox-beamer)
(require 'ox-twbs)
(require 'ox-hugo)
(require 'ox-gfm)

;; (setq org-hugo-external-file-extensions-allowed-for-copying 
;; 	  '("png" "jpg" "jpeg" "pdf" "txt"))




#+END_SRC
*** Org-extras
Remove headlines with =:no_title:= tag.
#+BEGIN_SRC emacs-lisp :results none
(require 'ox-extra)
(defun org-remove-headlines (backend)
  (org-map-entries (lambda () (delete-region (point-at-bol) (point-at-eol)))
                   "no_title"))

(add-hook 'org-export-before-processing-hook #'org-remove-headlines)
#+END_SRC
*** Capture
#+BEGIN_SRC emacs-lisp :results none
(setq org-reverse-note-order t)
(setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/Dropbox/orgfiles/todos/todos.org" "Captured TODOS")
         "* TODO %?\nAdded: %U\n" :prepend t :kill-buffer t)
        ("i" "Idea" entry (file+headline "~/Dropbox/orgfiles/notes.org" "Someday/Maybe")
         "* IDEA %?\nAdded: %U\n" :prepend t :kill-buffer t)
        ))

#+END_SRC
*** Reveal.js
This style of presenting looks cool but I don't use it that much. Still, I want to have the possibility in my emacs.
#+BEGIN_SRC emacs-lisp
(require 'ox-reveal)
(require 'htmlize)

(setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
(setq org-reveal-mathjax t)

#+END_SRC
*** Latex classes

#+BEGIN_SRC emacs-lisp :results none


(setq org-export-allow-bind-keywords 't)

(add-to-list 'org-latex-classes
                '("llncs"
                  "\\documentclass{llncs}"
                  ("\\section{%s}" . "\\section*{%s}")
                  ("\\subsection{%s}" . "\\subsection*{%s}")
                  ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))



#+END_SRC
*** Babel Languages
- Source block with this line in the header:

#+BEGIN_EXAMPLE
dot :file ./img/example1.png :cmdline -Kdot -Tpng
#+END_EXAMPLE
will produce a graph-png at the end....it's awesome!

#+BEGIN_SRC emacs-lisp :results none
(org-babel-do-load-languages
 (quote org-babel-load-languages)
 (quote (
         (emacs-lisp . t)
         (java . t)
         (dot . t)
         (ditaa . t)
         (R . t)
         (python . t)
         (ruby . t)
         (gnuplot . t)
         (clojure . t)
         (shell . t)
         (ledger . t)
         (org . t)
		   (plantuml . t)
         (plantuml . t)
         (latex . t))))

(setq org-plantuml-jar-path
      (expand-file-name "~/code_ext/plantuml.jar"))

#+END_SRC
*** Keybinds

#+BEGIN_SRC emacs-lisp :results none
(bind-key* "C-c a" 'org-agenda)
(bind-key* "C-c c" 'org-capture)
(bind-key* "C-c C-x s" 'org-attach-screenshot org-mode-map)
#+END_SRC

*** Org-Babel
For some reason I must set the right /python/ command each time I start emacs. This does the trick...sometimes. Running random snippets of code in /.org/ files...how bonkers is that. The answer is *pretty bonkers*!!(You know if you are into emacs if you get this "reference")
#+BEGIN_SRC emacs-lisp :results none
(setq org-babel-python-command "python")
#+END_SRC

*** Include PDFs as image

#+BEGIN_SRC emacs-lisp :results none


(defun org-include-img-from-pdf (&rest _)
  "Convert pdf files to image files in org-mode bracket links.

    # ()convertfrompdf:t # This is a special comment; tells that the upcoming
                         # link points to the to-be-converted-to file.
    # If you have a foo.pdf that you need to convert to foo.png, use the
    # foo.png file name in the link.
    [[./foo.png]]
"
  (interactive)
  (if (executable-find "convert")
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "^[ \t]*#\\s-+()convertfrompdf\\s-*:\\s-*t"
                                  nil :noerror)
          ;; Keep on going to the next line till it finds a line with bracketed
          ;; file link.
          (while (progn
                   (forward-line 1)
                   (not (looking-at org-bracket-link-regexp))))
          ;; Get the sub-group 1 match, the link, from `org-bracket-link-regexp'
          (let ((link (match-string-no-properties 1)))
            (when (stringp link)
              (let* ((imgfile (expand-file-name link))
                     (pdffile (expand-file-name
                               (concat (file-name-sans-extension imgfile)
                                       "." "pdf")))
                     (cmd (concat "convert -density 96 -quality 85 "
                                  pdffile " " imgfile)))
                (when (and (file-readable-p pdffile)
                           (file-newer-than-file-p pdffile imgfile))
                  ;; This block is executed only if pdffile is newer than
                  ;; imgfile or if imgfile does not exist.
                  (shell-command cmd)
                  (message "%s" cmd)))))))
    (user-error "`convert' executable (part of Imagemagick) is not found")))


(defun my/org-include-img-from-pdf-before-save ()
  "Execute `org-include-img-from-pdf' just before saving the file."
  (add-hook 'before-save-hook #'org-include-img-from-pdf nil :local))

;; Do not include this, it freezes when used in huge org buffers!
;; (add-hook 'org-mode-hook #'my/org-include-img-from-pdf-before-save)

#+END_SRC


*** Reloading
For some reasons I have to call this after I've /require/-d all the exporters' backends in order to make them available in the export dispatcher of /org-mode/.
#+BEGIN_SRC emacs-lisp :results none
(require 'org)
(org-reload)
#+END_SRC
** Latex

I used to use [[http://www.xm1math.net/texmaker/TexMaker/][/TexMaker/]] for writing my $\LaTeX$ documents but recent changes to its interface have made me look for alternative. Also, recent changes with me and me loving /Emacs/ have made the choice pretty easy. By know I don't think I miss anything that /TexMaker/ could offer me that /Emacs/ cannot.
- [[https://www.emacswiki.org/emacs/AUCTeX][auctex]] - full fledged environment for writing, editing and compiling /.tex/ documents. Almost everything comes out of the box. Only a simple setup and configuration is required.
- [[https://www.emacswiki.org/emacs/LaTeXPreviewPane][latex-preview-pane]] - The very cool feature of Tex/Maker/ where your generated /pdf/-document is displayed on the side. Yes. Emacs can do it too...surprise, surprise!!
#+BEGIN_SRC emacs-lisp :results none
(require 'tex)
(require 'latex-preview-pane)

(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq-default TeX-master nil)

(add-hook 'LaTeX-mode-hook 'visual-line-mode)
(add-hook 'LaTeX-mode-hook 'flyspell-mode)
(add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
(add-hook 'LaTeX-mode-hook 'pretty-mode)
(add-hook 'LaTeX-mode-hook 'prettify-symbols-mode)

(add-hook 'LaTeX-mode-hook 'turn-on-reftex)
(setq reftex-plug-into-AUCTeX t)

(TeX-global-PDF-mode t)

(setq TeX-view-program-list '(("Evince" "evince --page-index=%(outpage) %o")))
(setq TeX-view-program-selection '((output-pdf "Evince")))
(add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
(setq TeX-source-correlate-start-server t)

(setq org-latex-pdf-process (list
   "latexmk -pdflatex='lualatex -shell-escape -interaction nonstopmode' -pdf -f  %f"))

#+END_SRC

*** Keybinds
#+BEGIN_SRC emacs-lisp :results none
(bind-key* "C-c l p" 'latex-preview-pane-mode)
(bind-key* "C-c l b" 'helm-bibtex-with-local-bibliography)
(bind-key* "C-c l M-p" 'latex-preview-pane-update)
(bind-key* "C-c l l" 'TeX-command-master)
#+END_SRC

*** Templates
#+BEGIN_SRC emacs-lisp :results none
(setq org-structure-template-alist '(("a" . "export ascii")
									 ("c" . "center")
									 ("C" . "comment")
									 ("e" . "example")
									 ("E" . "export")
									 ("h" . "export html")
									 ("l" . "export latex")
									 ("q" . "quote")
									 ("s" . "src")
									 ("v" . "verse")))
#+END_SRC


* Editor enhancing

** Pretty startup screen
A dashboard(yeah, I know, pretend the name didn't say it) kind of thing that display on startup of/Emacs/ and gives quick access to recent files and projectile-projects. It works with sessions too but I haven't configured that yet. A image can also be displayed so I guess that is pretty. Custom startup message is a must of course!!
- [[https://github.com/rakanalh/emacs-dashboard][dashboard]]
#+BEGIN_SRC emacs-lisp :results none

(require 'dashboard)

(setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))

(setq dashboard-banner-logo-title "Welcome to the Emacs of Stanislav Arnaudov")

;; (setq dashboard-startup-banner 'official)
;; (setq dashboard-banner-logo-title "W I T C H M A C S")

(setq dashboard-startup-banner "~/.emacs.d/marivector.png")
(setq dashboard-center-content t)
(setq dashboard-show-shortcuts nil)

(setq dashboard-items '((recents  . 10)
                        (bookmarks . 5)
                        (projects . 10)
                        (agenda . 5)
                        (registers . 5)))
(dashboard-setup-startup-hook)


#+END_SRC

** Session persistence
Sometimes it gets really annoying when I close my emacs and have a bunch of buffers opened, the next time I launch the program, the buffers are gone and I have to open them again. Mind-blowing, I know, "So why do you close emacs?" - shut up, that's not the point . This package addresses my issues. I can even have custom sessions and open whole groups of tabs all at once
From the documentation:
#+BEGIN_EXAMPLE
<prefix> <key>
<prefix> c    - create workgroup
<prefix> A    - rename workgroup
<prefix> k    - kill workgroup
<prefix> v    - switch to workgroup
<prefix> C-s  - save session
<prefix> C-f  - load session
#+END_EXAMPLE
(kinda like cheat sheet)
---------
- [[https://github.com/pashinin/workgroups2][workgroups2]]
#+BEGIN_SRC emacs-lisp :results none
(require 'workgroups2)
(workgroups-mode 1)

(setq wg-prefix-key (kbd "C-c z"))
(setq wg-session-file "~/.emacs.d/.emacs_workgroups")
(setq wg-emacs-exit-save-behavior           'save)
(setq wg-workgroups-mode-exit-save-behavior 'save)
(setq wg-mode-line-display-on t)
(setq wg-flag-modified t)
(setq wg-mode-line-decor-left-brace "["
      wg-mode-line-decor-right-brace "]"
      wg-mode-line-decor-divider ":")
#+END_SRC

** Modeline
Making the modeline a little bit prettier and more spece efficient than the default. I should say that I am kind of guilty for liking the [[http://spacemacs.org][Spacemacs]] modeline a little too much. My current setup is more or less resembling that. The current package that I am using is [[https://github.com/TheBB/spaceline][spaceline]] which as far as I understand is created for people like me.
\\
Some of the packages for modelines that I've gone over are:
  - [[https://github.com/dbordak/telephone-line][telephone-line]]
  - [[https://github.com/Malabarba/smart-mode-line][smart-mode-line]]
 Preview:
 [[../mode-line.png]]
#+BEGIN_SRC emacs-lisp :results none
(require 'spaceline)
(require 'spaceline-config)
(require 'spaceline-all-the-icons)

(spaceline-helm-mode)
(spaceline-info-mode)

(setq powerline-default-separator 'wave)
(setq powerline-height 20)
(setq spaceline-all-the-icons-separator-type 'wave)

(spaceline-highlight-face-default)


(spaceline-toggle-all-the-icons-minor-modes-off)
(spaceline-toggle-all-the-icons-hud-on)
(spaceline-toggle-projectile-root-on)
(spaceline-toggle-version-control-on)
(spaceline-toggle-buffer-modified-on)
(spaceline-toggle-minor-modes-on)
(spaceline-toggle-projectile-root-on)
(spaceline-toggle-hud-off)
(spaceline-toggle-buffer-encoding-abbrev-off)



(if (daemonp)
    (add-hook 'after-make-frame-functions
        (lambda (frame)
          (with-selected-frame frame
            (spaceline-emacs-theme))))
    (spaceline-emacs-theme))


;; (spaceline-all-the-icons--setup-anzu)
;; (spaceline-all-the-icons--setup-package-updates)
;; (spaceline-all-the-icons--setup-git-ahead)
;; (spaceline-all-the-icons--setup-neotree)
;; (spaceline-all-the-icons-theme)
#+END_SRC

** Vimacs
/Vim+Emacs/
\\
Yes, from time to time I do find myself saying "Ugh, vim has that one nice feature which can so usefull here in Emacsland". For that reason, I've created a binding that allows me to quickly jump in and out of [[https://github.com/emacs-evil/evil][evil-mode]]. Evil -- or emulating vim layers as they call it -- is more or less full blown vim simulated in Emacs. The modal editing commands of vim are supported and are a joy to be used from time to time, even when one is hardcore Emacs fanboy. 
#+BEGIN_SRC emacs-lisp :results none

(defun quick-evil ()
  (interactive)
  (if (bound-and-true-p evil-local-mode)
    (progn
      (evil-local-mode (or -1 1))
      (undo-tree-mode (or -1 1))
      (set-cursor-color "#d0d0d0")
    )
    (progn
	  (evil-mode)
      (evil-local-mode (or 1 1))
      (set-variable 'cursor-type 'box)
      (set-cursor-color "#8968cd"))))

(bind-key* "M-<f13>" 'quick-evil)
#+END_SRC

** Which key
Now, I generally know my Emacs keybindings but from time to time I have to look somethings up. The [[https://github.com/justbur/emacs-which-key][which-key]] packages in awesome in this regard. If I the start of some keybinding, a popup will show me how can I follow the binding and which functions will be I executing if I type something.


#+BEGIN_SRC emacs-lisp :results none

(require 'which-key)
(which-key-mode)
(which-key-setup-side-window-bottom)

;; the default setup for the package
(setq which-key-idle-delay 1.0)
(setq which-key-max-description-length 27)
(setq which-key-add-column-padding 0)
(setq which-key-max-display-columns nil)
(setq which-key-separator "  " )
(setq which-key-unicode-correction 3)
(setq which-key-prefix-prefix "+" )
(setq which-key-special-keys nil)
(setq which-key-show-prefix 'left)
(setq which-key-show-remaining-keys nil)

#+END_SRC

** Diminish
The modeline can get pretty cluttered with minor modes pretty quickly. To avoid that I use the [[https://github.com/emacsmirror/diminish][diminish]] package. It allows me to specify modes that will not have any text in the modeline.
#+BEGIN_SRC emacs-lisp :results none
(require 'diminish)

#+END_SRC

***  Diminishing modes

#+BEGIN_SRC emacs-lisp :results none

(defun diminish-em-all ()
  "docstring"
  (interactive)
  (diminish 'smartparens-mode)
  (diminish 'wrap-region-mode)
  (diminish 'super-save-mode)
  (diminish 'volatile-highlights-mode)
  (diminish 'isearch-mode)
  (diminish 'yas-minor-mode)
  (diminish 'google-this-mode)
  (diminish 'wg-mode)
  (diminish 'workgroups-mode)
  (diminish 'drag-stuff-mode)
  (diminish 'flyspell-mode)
  (diminish 'helm-mode)
  (diminish 'eldoc-mode)
  (diminish 'global-framer-mode)
  (diminish 'framer-mode)
  (diminish 'anzu-mode)
  (diminish 'company-mode)
  (diminish 'beacon-mode)
  (diminish 'flycheck-mode)
  (diminish 'hungry-delete-mode)
  (diminish 'org-indent-mode)
  (diminish 'hs-minor-mode)
  (diminish 'which-key-mode)
  (diminish 'iedit-mode)
  (diminish 'modalka-mode "亮")
  (diminish 'visual-line-mode)
  (diminish 'hs-minor-mode)
  (diminish 'aggressive-indent-mode)
  (diminish 'org-indent-mode)
  (diminish 'irony-mode)
  (diminish 'function-args-mode)
  (diminish 'abbrev-mode)
  (diminish 'sphinx-doc-mode)
  (diminish 'org-indent-mode)
  (diminish 'ycmd-mode)
  (diminish 'modern-c++-font-lock-mode)
  (diminish 'doxymacs-mode)
  (message "The modes should be away now!"))

(diminish-em-all)
(bind-key* "M-j d" 'diminish-em-all)

#+END_SRC

** Highlight Symbol

#+BEGIN_SRC emacs-lisp :results none
(require 'highlight-symbol)
(highlight-symbol-nav-mode)
#+END_SRC
*** Faces
#+BEGIN_SRC emacs-lisp :results none


(setq highlight-symbol-colors (quote ("cyan")))

;; (face-spec-set 'highlight-symbol-face '((t (:background "royal blue" :foreground "black"))))


;; (face-spec-set 'highlight-indentation-current-column-face '((t (:background "gray"))))
;; (face-spec-set 'highlight-symbol-face '((t (:background "light blue"))))

#+END_SRC

*** Keybindgs
#+BEGIN_SRC emacs-lisp :results none
(bind-key* "M-o o" 'highlight-symbol)
(bind-key* "M-o M-o" 'highlight-symbol)

(bind-key* "M-n" 'highlight-symbol-next)
(bind-key* "M-p" 'highlight-symbol-prev)

(bind-key* "M-o c" 'highlight-symbol-remove-all)
(bind-key* "M-o M-c" 'highlight-symbol-remove-all)
#+END_SRC


* Mail

** Mu4e

#+BEGIN_SRC emacs-lisp :results none

(add-to-list 'load-path "~/code_ext/mu/mu4e")
(require 'mu4e)

(setq mu4e-maildir "/home/arnaud/.mail")

(setq
 message-send-mail-function 'smtpmail-send-it
 starttls-use-gnutls t
 mu4e-sent-messages-behavior 'sent
 user-mail-address "stanislav.arn@gmail.com"
 user-full-name "Stanislav Arnaudov"
 smtpmail-default-smtp-server "smtp.gmail.comg"
 smtpmail-smtp-user "stanislav.arn"
 smtpmail-smtp-server "smtp.gmail.com"
 smtpmail-stream-type 'starttls
 smtpmail-smtp-service 587)


(setq mu4e-trash-folder "/mu4e/Trash"
      mu4e-refile-folder "/mu4e/Archive"
	  mu4e-sent-folder "/mu4e/Sent"
	  mu4e-drafts-folder "/mu4e/Drafts"
      mu4e-attachment-dir "/mu4e/Downloads"
      mu4e-get-mail-command "offlineimap -q"
      mu4e-update-interval 300 ;; second
      mu4e-compose-signature-auto-include nil
      mu4e-view-show-images t
      mu4e-view-show-addresses t
      mu4e-use-fancy-chars t
	  )


(setq mu4e-contexts
    `( ,(make-mu4e-context
	  :name "Gmail"
	  :enter-func (lambda () (mu4e-message "Entering Gmail context"))
      :leave-func (lambda () (mu4e-message "Leaving Gmail context"))
	  ;; we match based on the contact-fields of the message
	  :match-func (lambda (msg)
			(when msg
			  (string-match-p "^/Gmail" (mu4e-message-field msg :maildir))))
	  :vars '( 
			  (mu4e-trash-folder . "/Gmail/[Gmail].Bin/")
			  ( user-mail-address	    . "stanislav.arn@gmail.com"  )
			  ( user-full-name	    . "Stanislav Arnaudov" )))))



(setq mu4e-context-policy 'pick-first)
(setq mu4e-compose-context-policy nil)


(require 'org-mu4e)
(setq org-mu4e-convert-to-html t)
(add-to-list 'mu4e-view-actions '("ViewInBrowser" . mu4e-action-view-in-browser) t)

;; (setq mu4e-maildir-shortcuts
;;     '( ("/INBOX"               . ?i)
;;        ("/[Gmail].Sent Mail"   . ?s)
;;        ("/[Gmail].Trash"       . ?t)
;;        ("/[Gmail].All Mail"    . ?a)))

;; (setq
;;    user-mail-address "USERNAME@gmail.com"
;;    user-full-name  "Foo X. Bar"
;;    mu4e-compose-signature
;;     (concat
;;       "Foo X. Bar\n"
;;       "http://www.example.com\n"))


(require 'mu4e-alert)


#+END_SRC

*** Keybindings

#+BEGIN_SRC emacs-lisp :results none
 
(bind-key* "C-x m" 'mu4e-compose-new)

#+END_SRC


* Things just for fun
The world is full of useless things! We should use them all!! Emacs agrees!!

** Weather
That one cool site - [[http://wttr.in/][wttr]] - that I even use in my system setup to get weather information. It can also be used in Emacs so why the hell not.
#+BEGIN_SRC emacs-lisp
(require 'wttrin)
(setq wttrin-default-cities '("Karlsruhe"
                              "Sliven"
                              "Sofia"))
(setq wttrin-default-accept-language
      '("Accept-Language" . "en-US"))

(bind-key* "M-j w"  'wttrin)

#+END_SRC


** XKCD
This cute little thing with those cool little nerdy cody comics
#+BEGIN_SRC emacs-lisp
(require 'xkcd)
(bind-key* "M-j x" 'xkcd)
#+END_SRC


** Touch typing
I... am not exactly a fast typist but I've really put time and effort into it. I regularly use [[https://typing-speed-test.aoeu.eu/][this]] one but Emacs is Emacs and everything should be Emacs. Just put everything in Emacs they said! So, [[https://github.com/mrkkrp/typit][typit]] is a small package that lets you practice touch typing right here into Emacs.
#+BEGIN_SRC emacs-lisp
(require 'typit)
(bind-key* "M-j t b" 'typit-basic-test)
(bind-key* "M-j t a" 'typit-advanced-test)
#+END_SRC


** Commands frequency
This things will track which command is being run and how many times... I just think it's cool.
#+BEGIN_SRC emacs-lisp
(require 'keyfreq)

(setq keyfreq-excluded-commands
        '(self-insert-command
          org-self-insert-command
          company-ignore
          abort-recursive-edit
          forward-char
          modalka-mode
          backward-char
          previous-line
          next-line))

(keyfreq-mode 1)
(keyfreq-autosave-mode 1)
#+END_SRC



#  LocalWords:  Yagist QOL

